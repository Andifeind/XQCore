<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>webdocs&#x2F;js&#x2F;xqcore-event.js - xqcore</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.8.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.8.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="xqcore"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.4.10</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/GetSet.html">GetSet</a></li>
            
                <li><a href="..&#x2F;classes/Manages event registering and emitting..html">Manages event registering and emitting.</a></li>
            
                <li><a href="..&#x2F;classes/XQCore.Logger.html">XQCore.Logger</a></li>
            
                <li><a href="..&#x2F;classes/XQCore.Presenter.html">XQCore.Presenter</a></li>
            
                <li><a href="..&#x2F;classes/XQCore.View.html">XQCore.View</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/XQCore Presenter.html">XQCore Presenter</a></li>
            
                <li><a href="..&#x2F;modules/XQCore.GetSet.html">XQCore.GetSet</a></li>
            
                <li><a href="..&#x2F;modules/XQCore.Logger.html">XQCore.Logger</a></li>
            
                <li><a href="..&#x2F;modules/XQCore.View.html">XQCore.View</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: webdocs&#x2F;js&#x2F;xqcore-event.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * XQCore EventEmitter
 *
 * Based on EventEmitter v4.0.2 by Oliver Caldwell
 * http:&#x2F;&#x2F;git.io&#x2F;ee
 *
 *&#x2F;
XQCore.Event = (function() {

	&#x2F;&#x2F;EventEmitter.js

	&#x2F;**
	 * EventEmitter v4.0.2 - git.io&#x2F;ee
	 * Oliver Caldwell
	 * MIT license
	 *&#x2F;

	var EventEmitter = (function() {
	    &#x2F;&#x2F; JSHint config - http:&#x2F;&#x2F;www.jshint.com&#x2F;
	    &#x2F;*jshint laxcomma:true*&#x2F;

	    &#x2F;&#x2F; Place the script in strict mode
	    &#x27;use strict&#x27;;

	    &#x2F;**
	     * Class for managing events.
	     * Can be extended to provide event functionality in other classes.
	     *
	     * @class Manages event registering and emitting.
	     *&#x2F;
	    function EventEmitter(){}

	    &#x2F;&#x2F; Shortcuts to improve speed and size

	        &#x2F;&#x2F; Easy access to the prototype
	    var proto = EventEmitter.prototype

	      &#x2F;&#x2F; Existence of a native indexOf
	      , nativeIndexOf = Array.prototype.indexOf ? true : false;

	    &#x2F;**
	     * Finds the index of the listener for the event in it&#x27;s storage array
	     *
	     * @param {Function} listener Method to look for.
	     * @param {Function[]} listeners Array of listeners to search through.
	     * @return {Number} Index of the specified listener, -1 if not found
	     *&#x2F;
	    function indexOfListener(listener, listeners) {
	        &#x2F;&#x2F; Return the index via the native method if possible
	        if(nativeIndexOf) {
	            return listeners.indexOf(listener);
	        }

	        &#x2F;&#x2F; There is no native method
	        &#x2F;&#x2F; Use a manual loop to find the index
	        var i = listeners.length;
	        while(i--) {
	            &#x2F;&#x2F; If the listener matches, return it&#x27;s index
	            if(listeners[i] === listener) {
	                return i;
	            }
	        }

	        &#x2F;&#x2F; Default to returning -1
	        return -1;
	    }

	    &#x2F;**
	     * Returns the listener array for the specified event.
	     * Will initialise the event object and listener arrays if required.
	     *
	     * @param {String} evt Name of the event to return the listeners from.
	     * @return {Function[]} All listener functions for the event.
	     * @doc
	     *&#x2F;
	    proto.getListeners = function(evt) {
	        &#x2F;&#x2F; Create a shortcut to the storage object
	        &#x2F;&#x2F; Initialise it if it does not exists yet
	        var events = this._events || (this._events = {});

	        &#x2F;&#x2F; Return the listener array
	        &#x2F;&#x2F; Initialise it if it does not exist
	        return events[evt] || (events[evt] = []);
	    };

	    &#x2F;**
	     * Adds a listener function to the specified event.
	     * The listener will not be added if it is a duplicate.
	     * If the listener returns true then it will be removed after it is called.
	     *
	     * @param {String} evt Name of the event to attach the listener to.
	     * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
	     * @return {Object} Current instance of EventEmitter for chaining.
	     * @doc
	     *&#x2F;
	    proto.addListener = function(evt, listener) {
	        &#x2F;&#x2F; Fetch the listeners
	        var listeners = this.getListeners(evt);

	        &#x2F;&#x2F; Push the listener into the array if it is not already there
	        if(indexOfListener(listener, listeners) === -1) {
	            listeners.unshift(listener);
	        }

	        &#x2F;&#x2F; Return the instance of EventEmitter to allow chaining
	        return this;
	    };

	    &#x2F;**
	     * Removes a listener function from the specified event.
	     *
	     * @param {String} evt Name of the event to remove the listener from.
	     * @param {Function} listener Method to remove from the event.
	     * @return {Object} Current instance of EventEmitter for chaining.
	     * @doc
	     *&#x2F;
	    proto.removeListener = function(evt, listener) {
	        &#x2F;&#x2F; Fetch the listeners
	        &#x2F;&#x2F; And get the index of the listener in the array
	        var listeners = this.getListeners(evt)
	          , index = indexOfListener(listener, listeners);

	        &#x2F;&#x2F; If the listener was found then remove it
	        if(index !== -1) {
	            listeners.splice(index, 1);

	            &#x2F;&#x2F; If there are no more listeners in this array then remove it
	            if(listeners.length === 0) {
	                this._events[evt] = null;
	            }
	        }

	        &#x2F;&#x2F; Return the instance of EventEmitter to allow chaining
	        return this;
	    };

	    &#x2F;**
	     * Adds listeners in bulk using the manipulateListeners method.
	     * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
	     * You can also pass it an event name and an array of listeners to be added.
	     *
	     * @param {String|Object} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
	     * @param {Function[]} [listeners] An optional array of listener functions to add.
	     * @return {Object} Current instance of EventEmitter for chaining.
	     * @doc
	     *&#x2F;
	    proto.addListeners = function(evt, listeners) {
	        &#x2F;&#x2F; Pass through to manipulateListeners
	        return this.manipulateListeners(false, evt, listeners);
	    };

	    &#x2F;**
	     * Removes listeners in bulk using the manipulateListeners method.
	     * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
	     * You can also pass it an event name and an array of listeners to be removed.
	     *
	     * @param {String|Object} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
	     * @param {Function[]} [listeners] An optional array of listener functions to remove.
	     * @return {Object} Current instance of EventEmitter for chaining.
	     * @doc
	     *&#x2F;
	    proto.removeListeners = function(evt, listeners) {
	        &#x2F;&#x2F; Pass through to manipulateListeners
	        return this.manipulateListeners(true, evt, listeners);
	    };

	    &#x2F;**
	     * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
	     * The first argument will determine if the listeners are removed (true) or added (false).
	     * If you pass an object as the second argument you can add&#x2F;remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
	     * You can also pass it an event name and an array of listeners to be added&#x2F;removed.
	     *
	     * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
	     * @param {String|Object} evt An event name if you will pass an array of listeners next. An object if you wish to add&#x2F;remove from multiple events at once.
	     * @param {Function[]} [listeners] An optional array of listener functions to add&#x2F;remove.
	     * @return {Object} Current instance of EventEmitter for chaining.
	     * @doc
	     *&#x2F;
	    proto.manipulateListeners = function(remove, evt, listeners) {
	        &#x2F;&#x2F; Initialise any required variables
	        var i
	          , value
	          , single = remove ? this.removeListener : this.addListener
	          , multiple = remove ? this.removeListeners : this.addListeners;

	        &#x2F;&#x2F; If evt is an object then pass each of it&#x27;s properties to this method
	        if(typeof evt === &#x27;object&#x27;) {
	            for(i in evt) {
	                if(evt.hasOwnProperty(i) &amp;&amp; (value = evt[i])) {
	                    &#x2F;&#x2F; Pass the single listener straight through to the singular method
	                    if(typeof value === &#x27;function&#x27;) {
	                        single.call(this, i, value);
	                    }
	                    else {
	                        &#x2F;&#x2F; Otherwise pass back to the multiple function
	                        multiple.call(this, i, value);
	                    }
	                }
	            }
	        }
	        else {
	            &#x2F;&#x2F; So evt must be a string
	            &#x2F;&#x2F; And listeners must be an array of listeners
	            &#x2F;&#x2F; Loop over it and pass each one to the multiple method
	            i = listeners.length;
	            while(i--) {
	                single.call(this, evt, listeners[i]);
	            }
	        }

	        &#x2F;&#x2F; Return the instance of EventEmitter to allow chaining
	        return this;
	    };

	    &#x2F;**
	     * Removes all listeners from a specified event.
	     * If you do not specify an event then all listeners will be removed.
	     * That means every event will be emptied.
	     *
	     * @param {String} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
	     * @return {Object} Current instance of EventEmitter for chaining.
	     * @doc
	     *&#x2F;
	    proto.removeEvent = function(evt) {
	        &#x2F;&#x2F; Remove different things depending on the state of evt
	        if(evt) {
	            &#x2F;&#x2F; Remove all listeners for the specified event
	            this._events[evt] = null;
	        }
	        else {
	            &#x2F;&#x2F; Remove all listeners in all events
	            this._events = null;
	        }

	        &#x2F;&#x2F; Return the instance of EventEmitter to allow chaining
	        return this;
	    };

	    &#x2F;**
	     * Emits an event of your choice.
	     * When emitted, every listener attached to that event will be executed.
	     * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
	     * Because it uses &#x60;apply&#x60;, your array of arguments will be passed as if you wrote them out separately.
	     * So they will not arrive within the array on the other side, they will be separate.
	     *
	     * @param {String} evt Name of the event to emit and execute listeners for.
	     * @param {Array} [args] Optional array of arguments to be passed to each argument.
	     * @return {Object} Current instance of EventEmitter for chaining.
	     * @doc
	     *&#x2F;
	    proto.emitEvent = function(evt, args) {
	        &#x2F;&#x2F; Get the listeners for the event
	        &#x2F;&#x2F; Also initialise any other required variables
	        var listeners = this.getListeners(evt)
	          , i = listeners.length
	          , response;

	        &#x2F;&#x2F; Loop over all listeners assigned to the event
	        &#x2F;&#x2F; Apply the arguments array to each listener function
	        while(i--) {
	            &#x2F;&#x2F; If the listener returns true then it shall be removed from the event
	            &#x2F;&#x2F; The function is executed either with a basic call or an apply if there is an args array
	            response = args ? listeners[i].apply(null, args) : listeners[i]();
	            if(response === true) {
	                this.removeListener(evt, listeners[i]);
	            }
	        }

	        &#x2F;&#x2F; Return the instance of EventEmitter to allow chaining
	        return this;
	    };

	    return EventEmitter;
	}());

	&#x2F;&#x2F;End EventEmitter.js


	var ee,
		event;
	
	function indexOf(eventName, callback) {
		this.objectName = &#x27;XQCore.Event&#x27;;
		
		var len = this.store.length,
			i = 0,
			el;

		for (; i &lt; len; i++) {
			el = this.store[i];
			if (eventName === null || eventName === el.event &amp;&amp; callback === null || callback === el.callback) {
				return el;
			}
		}

		return null;
	}


	event = function(conf) {
		this.store = [];
		this.ee = new EventEmitter();
	};

	&#x2F;&#x2F; event.prototype.on = function(eventName, callback) {

	&#x2F;&#x2F; };

	&#x2F;&#x2F; event.prototype.once = function(eventName, callback) {

	&#x2F;&#x2F; };

	&#x2F;&#x2F; event.prototype.emit = function(eventName, data) {

	&#x2F;&#x2F; };

	&#x2F;&#x2F; event.prototype.remove = function(eventName, callback) {

	&#x2F;&#x2F; };

	event.prototype.emit = function(eventName, data) {
		if (this.debug) {
			console.debug(&#x27;XQCore - Emit event&#x27;, eventName, data);
		}
		return this.ee.emitEvent(eventName, [data], this);
	};

	event.prototype.on = function(eventName, listener) {
		if (this.debug) {
			console.debug(&#x27;XQCore - Add listener&#x27;, eventName, listener, this);
		}
		return this.ee.addListener(eventName, listener);
	};

	event.prototype.once = function(eventName, listener) {
		var onceListener = function() {
			this.ee.removeListener(eventName, listener);
			listener.apply(null, arguments);
			return true;
		}.bind(this);

		if (this.debug) {
			console.debug(&#x27;XQCore - Add once listener&#x27;, eventName, listener);
		}
		return this.ee.addListener(eventName, onceListener);
	};

	event.prototype.off = function(eventName, listener) {
		if (this.debug) {
			console.debug(&#x27;XQCore - Remove listener&#x27;, eventName, listener);
		}

		if (listener === undefined) {
			return this.ee.removeEvent(eventName);
		}
		else {
			return this.ee.removeListener(eventName, listener);
		}
	};

	event.prototype.removeAllListener = function() {
		if (this.debug) {
			console.debug(&#x27;XQCore - Clear all listener&#x27;);
		}

		return this.ee.removeEvent();
	};

	event.prototype.getListeners = function(eventName) {
		return this.ee.getListeners(eventName);
	};

	return event;
})();

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
