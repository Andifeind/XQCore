var XQCore=require("./src/xqcore-core");XQCore.Promise=require("./src/xqcore-promise"),XQCore.Logger=require("./src/xqcore-logger"),XQCore.ReadyState=require("./src/xqcore-readystate"),XQCore.Event=require("./src/xqcore-event"),XQCore.Sync=require("./src/xqcore-sync"),XQCore.List=require("./src/xqcore-list"),XQCore.Model=require("./src/xqcore-model"),XQCore.Presenter=require("./src/xqcore-presenter"),XQCore.Router=require("./src/xqcore-router"),XQCore.Service=require("./src/xqcore-service"),XQCore.SocketConnection=require("./src/xqcore-socket-connection"),XQCore.Socket=require("./src/xqcore-socket"),XQCore.SyncList=require("./src/xqcore-synclist"),XQCore.SyncModel=require("./src/xqcore-syncmodel"),XQCore.Tmpl=require("./src/xqcore-tmpl"),XQCore.View=require("./src/xqcore-view"),require("./src/xqcore-utils"),module.exports=XQCore;/**
 * XQCore core module
 * @module XQCore
 */
var $=require("jquery"),XQCore={/**
     * Contains the current XQCore version
     * @property {String} version
     */
version:"0.13.1",/**
     * Defines a default route
     * @property {String} defaultRoute
     */
defaultRoute:"/",/**
     * Enables html5 routing support
     * @property {Boolean} html5Routes
     * @default false
     */
html5Routes:!1,/**
     * Defines a base path of your projewt
     * @type {String}
     */
basePath:"",/**
     * Sets a hashbang for routing. This value is added to each route if html5Routes is set to false
     * @property {String} hashBang
     */
hashBang:"#!",/**
     * Sets the default template engine
     * @property {String} templateEngine
     * @default firetpl
     */
templateEngine:"firetpl",/**
     * Sets a views directory
     * @property {String} viewsDir
     */
viewsDir:"./views/",/**
     * Set the file extension for views
     * @property {String} viewExt
     */
viewExt:".fire",/**
     * Defines a default socket port
     * @property {Number} socketPort
     * @default 9889
     */
socketPort:9889,/**
     * Sets max length of event listener
     * @property {Number} eventListenerMaxLength
     * @default  1328
     */
eventListenerMaxLength:1328};/**
 * Merges the properties from one or more objects together into a target object
 * Its simply an alias for jQuery.extend.
 * 
 * @method extend
 * @param {Boolean} [deep] If true, a deep merge is using
 * @param {Object} target Target object. This object will be extended with new properties
 * @param {Object} [object1] Object to merge
 * @param {Object} [objectN] Object to merge
 * @return {Object} Returns the merged target object
 * @example {js}
 * var target = {
 *     a: 'A1',
 *     b: 'B1'
 * }
 *
 * var obj1 = {
 *     b: 'B2',
 *     c: 'C2'
 * }
 *
 * extend(target, obj1);
 * //Returns {a: 'A1', b: 'B2', c: 'C2'}
 *  
 */
Object.defineProperty(XQCore,"extend",{enumerable:!1,configurable:!0,writable:!0,value:function(a){if(void 0===a||null===a)throw new TypeError("Cannot convert first argument to object");for(var b=Object(a),c=1;c<arguments.length;c++){var d=arguments[c];if(void 0!==d&&null!==d){d=Object(d);for(var e=Object.keys(d),f=0,g=e.length;g>f;f++){var h=e[f],i=Object.getOwnPropertyDescriptor(d,h);void 0!==i&&i.enumerable&&(b[h]=d[h])}}}return b}}),/**
 * Checks whether an value is a plain object
 * @method isPlainObject
 *
 * @param {Object} obj The value which should be checked
 * @returns {Boolean} Returns true if value is a function, otherwise returns false
 */
XQCore.isPlainObject=$.isPlainObject,/**
 * Checks whether an value is a function
 * @method isPlainObject
 *
 * @param {Object} obj The value which should be checked
 * @returns {Boolean} Returns true if value is a plain object, otherwise returns false
 */
XQCore.isFunction=$.isFunction,/**
 * Checks for a valid ObjectId
 * 
 * The pattern of an objectId can be overwritten by setting the XQCore.objectIdPattern property
 *
 * @return {Boolean} Returns true if value is an valid objectId
 */
XQCore.isObjectId=function(a){return/^[a-zA-Z0-9]{24}$/.test(a)},/**
 * Set a local for the current session
 * 
 * @method setLocale
 * @param  {String}  locale Local string
 */
XQCore.setLocale=function(a){localStorage.setItem("xqcore.locale",a)},/**
 * Returns a local string
 * @method getLocale
 * @return {[type]}  [description]
 */
XQCore.getLocale=function(){var a=localStorage.getItem("xqcore.locale");return a?a:navigator.language},/**
 * Defines a global log level
 *
 * XQCore has 5 log levels
 *
 * 0 = off
 * 1 = error
 * 2 = warning
 * 3 = info
 * 4 = debug
 * 5 = trace
 * 
 * @property {String} logLevel
 */
XQCore.logLevel=1,/**
 * Returns one or all queries
 * Converts all numeric items to a Number
 *
 * @method getQuery
 * @param  {String} name Query name
 * @return {Object|String}      Returns all queries or one value.
 */
XQCore.getQuery=function(a){return XQCore.__query||(XQCore.__query={},location.search.substr(1).split("&").forEach(function(a){if(a=a.split("="),a&&a[0]){var b=encodeURI(a[1]);XQCore.__query[a[0]]=isNaN(b)?b:Number(b)}})),a?XQCore.__query[a]:XQCore.__query},/**
 * Checks whether an object is an empty object
 * @param  {Object}  obj Object which should be checked
 * @return {Boolean}     Returns true if object is empty
 */
XQCore.isEmptyObject=function(a){var b;
//jshint forin:false
for(b in a)return!1;return!0},/**
 * Checks whether an object is an empty object or an empty array
 * @param  {Object|Array}  obj Object which should be checked
 * @return {Boolean}     Returns true if obj is empty
 */
XQCore.isEmpty=function(a){return Array.isArray(a)?0===a.length:XQCore.isEmptyObject(a)},
//--
module.exports=XQCore;var XQCore=require("./xqcore-core"),Logger=function(a){this.loggerName=a,this.logLevel=XQCore.logLevel};/**
 * Logs a message to the console.
 *
 * To log a message of this type a minimum logLevel of INFO is required.
 * Only the first given argument will be logged if log level is set to INFO.
 * To log all arguments, log level must be set to DEBUG.
 *
 * This method can have multiple arguments!
 *
 * @method log
 * @example {js}
 * log.logLevel = 3; //INFO
 * log.log('Write to console', {test: '123'});
 * //Logs only the first argument
 *
 * log.logLevel = 4;
 * log.log('Write to console with args', {test: '123'});
 * //Logs all arguments
 *
 * @param {Any} msg logs all arguments to the console
 */
Logger.prototype.log=function(){var a;XQCore.logLevel>=3&&(a=Array.prototype.slice.call(arguments),this.loggerName&&a.unshift("["+this.loggerName+"]"),console.log.apply(console,a))},/**
 * Logs a warning message to the console.
 *
 * To log a warning message of this type a minimum logLevel of WARNING is required.
 *
 * This method can have multiple arguments!
 *
 * @method warn
 * @example {js}
 * log.logLevel = 2; //WARNING
 * log.warn('Unvalid number', {test: '123'});
 *
 * @param {Any} msg logs all arguments to the console
 */
Logger.prototype.warn=function(){var a;XQCore.logLevel>=2&&(a=Array.prototype.slice.call(arguments),this.loggerName&&a.unshift("["+this.loggerName+"]"),console.warn.apply(console,a))},/**
 * Logs a error message to the console.
 *
 * To log a error message of this type a minimum logLevel of WARNING is required.
 *
 * This method can have multiple arguments!
 *
 * @method error
 * @example {js}
 * log.logLevel = 1; //ERROR
 * log.error('Unvalid number', {test: '123'});
 *
 * @param {Any} msg logs all arguments to the console
 */
Logger.prototype.error=function(){var a;XQCore.logLevel>=1&&(a=Array.prototype.slice.call(arguments),this.loggerName&&a.unshift("["+this.loggerName+"]"),console.error.apply(console,a))},/**
 * Logs a debug message to the console.
 *
 * To log a debug message of this type a minimum logLevel of DEBUG is required.
 * Only the first given argument will be logged if log level is set to DEBUG.
 * To log all arguments, log level must be set to TRACE.
 *
 * This method can have multiple arguments!
 *
 * @method debug
 * @example {js}
 * log.logLevel = 3; //DEBUG
 * log.debug('Write to console', {test: '123'});
 * //Logs only the first argument
 *
 * log.logLevel = 4;
 * log.debug('Write to console with args', {test: '123'});
 * //Logs all arguments
 *
 * @param {Any} msg logs all arguments to the console
 */
Logger.prototype.debug=function(){var a;XQCore.logLevel>=4&&(a=Array.prototype.slice.call(arguments),this.loggerName&&a.unshift("["+this.loggerName+"]"),console.debug.apply(console,a))},/**
 * Logs a log message to the console. This is just an alias for log
 *
 * @method info
 */
Logger.prototype.info=Logger.prototype.log,/**
 * Start a timeTracer
 *
 * @method timer
 * @param {String} timerName Set the name for your (Optional)
 * @return {Object} Returns a TimerObject
 */
Logger.prototype.timer=function(a){var b=this,c={start:null,stop:null,name:a,logger:this,end:function(){this.stop=Date.now(),this.logger.log("Timer "+a+" finished after "+b.getHumanTime(this.stop-this.start))}};/*if (name) {
        this.timerStore[name] = timer;
    }*/
//Set timer start time
return this.log("Start Timer "+a),c.start=Date.now(),c},
// --- new methods
Logger.prototype.dev=function(){this.warn("Logger.dev() is deprcated since v0.13! Use Logger.debug() instead"),this.debug.call(arguments)},Logger.prototype.req=Logger.prototype.log,Logger.prototype.res=Logger.prototype.log,/**
 * Returns a human readable time format
 * @method getHumanTime
 * @private
 * @param  {Number}     time Time in milliseconds
 * @return {String}          Returns a readable time string
 */
Logger.prototype.getHumanTime=function(a){return 1e3>a?a+"ms":6e4>a?Math.round(a/100)/10+"sec":Math.round(a/6e4)+"min "+Math.round(a%6e4/1e3)+"sec"},
//--
module.exports=Logger;var XQCore=require("./xqcore-core");XQCore.undotify=function(a,b){return a&&(a=a.split("."),a.forEach(function(a){b=b?b[a]:void 0})),b},/**
 * Creates a object from an dotified key and a value
 *
 * @public
 * @method dedotify
 * 
 * @param {Object} obj Add new value to obj. This param is optional.
 * @param {String} key The dotified key
 * @param {Any} value The value
 *
 * @returns {Object} Returns the extended object if obj was set otherwis a new object will be returned
 */
XQCore.dedotify=function(a,b,c){"string"==typeof a&&(c=b,b=a,a={});var d=a;if(b){b=b.split(".");var e=b.length;b.forEach(function(b,d){return d===e-1?/\[\]$/.test(b)?(b=b.substr(0,b.length-2),a[b]||(a[b]=[]),void a[b].push(c)):void(a[b]=c):(a[b]||(a[b]={}),void(a=a[b]))})}return a=c,d},/**
 * Creates a unique id
 *
 * @param {Number} len (Optional) String length. Defaults to 7
 * @returns {String} Unique string
 */
XQCore.uid=function(a){a=a||7;for(var b="";b.length<a;){var c=Math.random().toString(36).substr(2);b+=c}return b.substr(0,a)},/**
 * Returns a promise object
 *
 * the returning object has two extra methods
 *
 * `resolve` to resolv the promise
 * `reject` to reject the promise
 *
 * If callback is set it will be called, when promise will be resolved or rejected.
 * Gets the reject data as first argument and the resolve data as second argument
 *
 * @example {js}
 * var promise = XQCore.promise();
 * promise.then(function() {
 *     console.log('Resolve');
 * });
 * 
 * setTimeout(function() {
 *     promise.resolve();
 * }, 100);
 *     
 * @method promise
 * @param  {Function} [callback] Callback function, to be called on resolv or rejecting the promise
 * @return {Object} Returns a promise object
 */
XQCore.promise=function(a){var b,c,d=new XQCore.Promise(function(a,d){b=a,c=d});d.resolve=function(c){return b(c),"function"==typeof a&&a(null,c),d},d.reject=function(b){return c(b),"function"==typeof a&&a(b),d};var e=[];return d.push=function(a){if("function"!=typeof a)throw new Error("Could not create a promise chain! First arg is not a function in promise.push().");return e.push(a),this},d.each=function(a){var b=e.shift();return b?(b(a).then(function(a){d.each(a)})["catch"](function(a){d.reject(a)}),d):void d.resolve(a)},d};var XQCore=require("./xqcore-core"),log,EventListener=function(a,b,c){this.fn=c,this.calls=0,this.once=!1,/**
     * Removes this event listener
     * @group XQCore.Event.EventListener
     * @private
     * @method remove
     * @return {Boolean} Returns true if event was removed
     */
this.remove=function(){a.off(b,c)}},EventEmitter=function(){log=new XQCore.Logger("EventEmitter"),this.__events={},this.__logger=log,this.maxLength=XQCore.eventListenerMaxLength};/**
 * Registers an event listener
 * @method on
 * @param  {String}   event Event name
 * @param  {Function} fn    Event function
 * @return {Object}         Returns an EventListener instance
 */
EventEmitter.prototype.on=function(a,b){var c=new EventListener(this,a,b);return this.__events[a]||(this.__events[a]=[]),this.__events[a].push(c),this.__events[a].length>this.maxLength?log.warn("Listener max length was exceeded!","List:",a,"Length:",this.__events[a].length):log.info("Register new `"+a+"` event"),c},/**
 * Registers an once event listener. This listener is called only once a time.
 *
 * @method once
 * @param  {event}  event  Event name
 * @param  {Function} fn    Event function
 * @return {Object}         Returns an EventListener instance
 */
EventEmitter.prototype.once=function(a,b){var c=Array.prototype.slice.call(arguments),d=this.on.apply(this,c);return d.once=!0,d},/**
 * Emits an event
 * @method emit
 * @param  {String} event Event name
 * @param  {Any} data  Event data, you can use multiple args here
 * @return {Number}    Returns the number of emited events
 */
EventEmitter.prototype.emit=function(a,b){if(!this.__events[a])return log.info("Emit `"+a+"` event failed! No listener of this type are registered"),0;for(var c=Array.prototype.slice.call(arguments,1),d=this.__events[a].length,e=d-1;e>=0;e--){var f=this.__events[a][e];f.fn.apply(this,c),f.calls++,f.once===!0&&this.__events[a].splice(e,1)}return d&&(log.info("Emit `"+a+"` event to",d,"listener"),log.debug(" ... data:",b)),d},/**
 * Unregisters events
 *
 * @method off
 * @param  {String}  event  Event name
 * @param  {Function}  [fn]  Event function. If this property is set only that function will be removed. Otherwis all events of this name will be removed
 * @return {Number} Returns the number of removed events
 */
EventEmitter.prototype.off=function(a,b){var c=0;if(!this.__events[a])return log.info("Unregister events failed! No `"+a+"` events were found!"),0;if(b)for(var d=this.__events[a].length,e=0;d>e;e++){var f=this.__events[a][e];f&&f.fn===b&&(this.__events[a].splice(e,1),c++,0===this.__events[a].length&&delete this.__events[a])}else c=this.__events[a].length,delete this.__events[a];return log.info("Unregister `"+a+"` events!","Removed "+c+" listener"),c},/**
 * Removes all registered events
 * @method clear
 * @return {Number} Returns the number of removed events
 */
EventEmitter.prototype.clearEvents=function(){this.__events={}},
//--
module.exports=EventEmitter;/**
 * XQCore.ReadyState module
 * 
 * Holds a function call until a state becomes ready
 * 
 * @module XQCore.ReadyState
 */
var ReadyState=function(){this.__isReady=!1,this.__readyFuncs=[]};/**
 * Wait till view is ready
 *
 * @method ready
 * @param {Function} fn FUnction to be called if state becomes ready
 */
ReadyState.prototype.ready=function(a){this.__isReady?a.call(this):this.__readyFuncs.push(a)},/**
 * Sets a state ready and calls all retained functions
 * 
 * @method setReady
 */
ReadyState.prototype.setReady=function(){var a=this;this.__isReady=!0,this.__readyFuncs&&(this.__readyFuncs.forEach(function(b){b.call(a)}),this.__readyFuncs=[])},/**
 * Unsets a ready state
 * 
 * @method unsetReady
 */
ReadyState.prototype.unsetReady=function(){this.__isReady=!1},
//--
module.exports=ReadyState;var XQCore=require("./xqcore-core"),$=require("jquery"),Sync=function(){/**
     * Sets a server URI
     *
     * This URI is used by all send methods as default server URI
     * @property {String} server
     */
this.server=null};/**
 * Called on before sending an ajax request
 * You can use this function to manipulate all data they be send to the server
 *
 * @param {Object} data The data to send to the server
 * @return {Object} data
 */
Sync.prototype.onSend=function(a){return a},/**
 * Send an ajax request to the webserver.
 *
 * You must set the server URI first with model.server = 'http://example.com/post'
 *
 * @param {String} Method send method, GET, POST, PUT, DELETE (default POST)
 * @param {String} url Server URL (optional, then model.server must be set)
 * @param {Object} data The data to sent to the server
 * @param {Function} callback Calls callback(err, data, status, jqXHR) if response was receiving
 */
Sync.prototype.send=function(a,b,c,d){var e=this;"object"==typeof b?(d=c,c=b,b=this.server,a=a):"function"==typeof c?(d=c,c=this.toJSON?this.toJSON():null):void 0===c&&(c=this.toJSON?this.toJSON():null),void 0===a&&(a="POST"),b||(b=this.server),"GET"===a&&Array.isArray(c)&&(b=b.replace(/\/$/,"")+"/"+c.join("/"),c=null),
//Handle onSend
"function"==typeof this.onSend&&(c=this.onSend.call(this,c)),this.log("Send an ajax call to ",b,"with data: ",c),this.state("syncing");var f=new Promise(function(f,g){$.ajax({url:b,type:a,data:XQCore.isEmpty(c)?null:JSON.stringify(c),dataType:"json",contentType:"application/json",headers:{Accept:"application/json"},success:function(a,b,c){"function"==typeof d&&d.call(e,null,a,b,c),e.state("success"),f(a)},error:function(a,b,c){"function"==typeof d&&d.call(e,{type:b,http:c},null,b,a),e.state("failed"),g({type:b,http:c})}})});return f},/**
 * Sends a POST to the Datastore
 *
 * @param {String} url Server URL (optional, then model.server must be set)
 * @param  {Object}   data     Dato to sending
 * @param  {Function} callback Calling on response
 *
 * callback: void function(err, data, status, jqXHR)
 *
 */
Sync.prototype.sendPOST=function(a,b,c){return this.send("POST",a,b,c)},/**
 * Sends a GET to the Datastore
 *
 * @param {String} url Server URL (optional, then model.server must be set)
 * @param  {Object}   data     Dato to sending
 * @param  {Function} callback Calling on response
 *
 * callback: void function(err, data, status, jqXHR)
 *
 */
Sync.prototype.sendGET=function(a,b,c){return this.send("GET",a,b,c)},/**
 * Sends a PUT to the Datastore
 *
 * @param {String} url Server URL (optional, then model.server must be set)
 * @param  {Object}   data     Dato to sending
 * @param  {Function} callback Calling on response
 *
 * callback: void function(err, data, status, jqXHR)
 *
 */
Sync.prototype.sendPUT=function(a,b,c){return this.send("PUT",a,b,c)},/**
 * Sends a DELETE to the Datastore
 *
 * @param {String} url Server URL (optional, then model.server must be set)
 * @param  {Object}   data     Dato to sending
 * @param  {Function} callback Calling on response
 *
 * callback: void function(err, data, status, jqXHR)
 *
 */
Sync.prototype.sendDELETE=function(a,b,c){return this.send("DELETE",a,b,c)},/**
 * Fetch data from server
 *
 * @param {Object} query MongoDB query 
 * @param {Function} callback Callback function
 */
Sync.prototype.fetch=function(a,b){return this.sendGET(a,b)},/**
 * Save a model if it's valid
 */
Sync.prototype.save=function(a,b){return"function"==typeof a&&(b=a,a=this.schema?this.getByKeys(Object.keys(this.schema)):this.toJSON()),this.isValid()?this.sendPOST(a,b):"function"!=typeof b?Promise.reject({msg:"Model isn't valid. Cancle save"}):void b({msg:"Model isn't valid. Cancle save"})},/**
 * Update a model if it's valid
 */
Sync.prototype.update=function(a,b){"function"==typeof a&&(b=a,a=this.schema?this.getByKeys(Object.keys(this.schema)):this.toJSON()),this.isValid()?this.sendPUT(a,b):"function"==typeof b&&b({msg:"Model isn't valid. Cancel update"})},/**
 * To be called when a form was submited in a coupled model
 *
 * This method merges submited form data with model.
 * If validation doesn't fail, update or save methode have to be called.
 * It calls update if data.id is not undefined, otherwise it calls save
 * Override this function if this behavior isn't desired 
 * 
 * @method sync
 * @override
 * @param  {Any} data     data
 */
Sync.prototype.submit=function(a){var b=this,c=new Promise(function(c,d){b.set(a,{extend:!0}).then(function(){b.server&&(void 0===b.get("id")||null===b.get("id")?b.save(a).then(function(a){c(a),b.emit("data.submit",a)})["catch"](function(a){d(a)}):b.update(a).then(function(a){c(a),b.emit("data.submit",a)})["catch"](function(a){d(a)}))})});return c},
//--
module.exports=Sync;var XQCore=require("./xqcore-core"),log,Presenter=function(a,b){var c=this;"function"==typeof arguments[0]&&(b=a,a=null),/**
     * Set presenter name
     * @public
     * @type {String}
     */
this.name=a||"Nameless",/**
     * Router instance
     * @private
     * @type {Object}
     */
this.router=XQCore.Router.getInstance(),log=new XQCore.Logger(this.name+"Presenter"),this.__views={},"function"==typeof b&&b.call(this,c,log)};XQCore.extend(Presenter.prototype,new XQCore.Event),/**
 * Add a history item to the browser history
 *
 * @method pushState
 *
 * @param {String} url Page URL (Optional) defaults to the curent URL
 * @param {Object} data Data object
 */
Presenter.prototype.pushState=function(a,b){
// log.info('Check State', data, history.state, XQCore.compare(data, history.state));
// if (XQCore.compare(data, history.state)) {
//     this.warn('Abborting history.pushState because data are equale to current history state');
// }
var c=XQCore.html5Routes||"/"===a.charAt(0)?"":XQCore.hashBang;a=c+a,history.pushState(b,"",a||null),log.info("Update history with pushState. New URL: "+b,a)},/**
 * Add a history item to the browser history
 *
 * @method replaceState
 *
 * @param {String} url Page URL (Optional) defaults to the current URL
 * @param {Object} data Data object
 */
Presenter.prototype.replaceState=function(a,b){var c=XQCore.html5Routes||"/"===a.charAt(0)?"":XQCore.hashBang;a=c+a,history.replaceState(b,"",a||null),log.info("Update history with replaceState. New URL: "+b,a)},/**
 * Navigates to a given route
 *
 * @method  navigateTo
 *
 * Options: {
 *  replace: <Boolean> Replace current history entry with route (Only when html5 routes are enabled)
 *  noPush: <Boolean> Set this to false to surpress a route change when new route equals to old route
 * }
 *
 * @param {String} route Route url
 * @param {Object} options Options
 */
Presenter.prototype.navigateTo=function(a,b){b=b||{},XQCore.html5Routes?this.router.callRoute(a,b):(location.hash=XQCore.hashBang+a,this.router.callRoute(a,b))},/**
 * Navigate back
 * 
 * @method navigateBack
 */
Presenter.prototype.navigateBack=function(){history.back()},/**
 * Gets a view by it's name
 *
 * @method getView
 * @param {String} viewName Required view name
 * @return {Object} Returns view object or null if no view was found
 */
Presenter.prototype.getView=function(a){return this.__views[a]||null},/**
 * Returns the current hash
 *
 * @method getHash
 * @returns {String} Returns the current value from location.hash
 */
Presenter.prototype.getHash=function(){return location.hash},/**
 * Returns the current pathname
 *
 * @method getPathname
 * @returns {String} Returns the current value from location.pathname
 */
Presenter.prototype.getPathname=function(){return location.pathname},/**
 * Couple a model with a view
 *
 * @method couple
 * @chainable
 * @param {Object} conf Configuration object
 *
 * conf: {
 *   model: String modelname
 *   view: String viewname
 *   route String routename
 * }
 */
Presenter.prototype.couple=function(a,b,c){c=c||{},b instanceof XQCore.List?this.coupleList(a,b,c):this.coupleModel(a,b,c),this.coupleView(a,b,c)},/**
 * Couples a view onto a model
 *
 * @method coupleModel
 * @param {Object} view XQCore.View instance
 * @param {Object} model XQCore.Model instance
 */
Presenter.prototype.coupleModel=function(a,b,c){if(c=c||{},!(a instanceof XQCore.View))return log.error("Could not couple model with view. First arg is not a valid view!");if(!(b instanceof XQCore.Model))return log.error("Could not couple model with view. Second arg is not a valid model!");b.__coupled&&b.__coupled.uncouple(),log.info("Couple model",b.name,"with",a.name),b.__coupled={obj:a,events:[],uncouple:function(){log.info("Uncouple model",b.name,"from",a.name),b.__coupled.events.forEach(function(a){a.remove()}),delete b.__coupled}};var d={"data.replace":"render","data.set":"render","value.set":"change",
// 'item.insert': 'xrender',
"item.remove":"remove","validation.error":"validationFailed","state.change":"onStateChange"},e=function(c,d){var e="function"==typeof d?d:a[d].bind(a),f=b.on(c,e);b.__coupled.events.push(f)};for(var f in d)d.hasOwnProperty(f)&&e(f,d[f]);
//Initial view render with current model data
a.render(b.get())},/**
 * Couples a listwith a view
 *
 * @method coupleList
 * @param {Object} view XQCore.View instance
 * @param {Object} model XQCore.Model instance
 */
Presenter.prototype.coupleList=function(a,b){if(!(a instanceof XQCore.View))return log.error("Could not couple list with view. First arg is not a valid view!");if(!(b instanceof XQCore.List))return log.error("Could not couple list with view. Second arg is not a valid list!");b.__coupled&&b.__coupled.uncouple(),log.info("Couple list",b.name,"with",a.name),b.__coupled={obj:a,events:[],uncouple:function(){log.info("Uncouple list",b.name,"from",a.name),b.__coupled.events.forEach(function(a){a.remove()}),delete b.__coupled}};var c={"item.push":function(b){a.append("_ftl_root",b[0].toJSON())},"item.unshift":"prepend","item.pop":"removeLast","item.shift":"removeFirst","item.update":"update","item.remove":function(b,c){a.remove("_ftl_root",c)},"state.change":"onStateChange"},d=function(c,d){var e="function"==typeof d?d:a[d].bind(a),f=b.on(c,e);b.__coupled.events.push(f)};for(var e in c)c.hasOwnProperty(e)&&d(e,c[e]);
//Initial view render with current list data
a.render(b.toArray())},/**
 * Couples a view with a model or a list
 *
 * @method coupleView
 * @param {Object} view XQCore.View instance
 * @param {Object} model XQCore.Model or XQCore.List instance
 */
Presenter.prototype.coupleView=function(a,b){if(!(a instanceof XQCore.View))return log.error("Could not couple list with view. First arg is not a valid view!");if(!(b instanceof XQCore.Model||b instanceof XQCore.List))return log.error("Could not couple list with view. Second arg is not a valid model or list!");a.__coupled&&a.__coupled.uncouple(),log.info("Couple view",a.name,"with",b.name),a.__coupled={obj:b,events:[],uncouple:function(c){log.info("Uncouple view",a.name,"from",b.name),a.__coupled.events.forEach(function(a){a.remove()}),delete a.__coupled}};var c;c=b instanceof XQCore.Model?{"form.submit":"submit","input.change":"set","input.edit":function(c,d){var e=b.checkValidation(c,d);e?a.validationSucceeded(c,d):a.validationFailed([{property:name}])}}:{"form.submit":"submit"};var d=function(c,d){var e="function"==typeof d?d:b[d].bind(b),f=a.on(c,e);a.__coupled.events.push(f)};for(var e in c)c.hasOwnProperty(e)&&d(e,c[e])},/**
 * Initialize a new view into the presenter scope
 *
 * options: {
 *   mode: String       Insert mode, (append, prepend or replace) replace is default
 *   inject: Boolean    Set to false to disable injecting view into the DOM
 *   forms: Boolean|String     View has forms. Add a selector here or set this to true to find all forms
 * }
 * 
 * @method initView
 * @public
 * @param  {String} viewName  Name of the view
 * @param  {String} container Container selector, default is 'body'
 * @param  {Object} options   View options
 * @return {Object}           Returns a view object
 */
Presenter.prototype.initView=function(a,b,c){c=c||{};var d={};c.viewDir&&(d.viewDir=c.viewDir);var e=new XQCore.View(a,function(e){e.template=XQCore.Tmpl.getTemplate(a,d),e.mode=c.mode||"replace",e.container=b||"body",e.hidden=!!c.hidden,e.forms=c.forms,c.inject===!1&&(e.autoInject=!1)});this.__views[a]=e;var f=this;return XQCore.html5Routes&&e.on("xqcore.navigate",function(a){f.router.callRoute(a)}),e},/**
 * Register a route listener
 *
 * @public
 * @method route
 * @chainable
 * @param {String | Array} route Route string
 * @param {Function} callback Callback function
 * @returns {Object} Returns this value
 */
Presenter.prototype.route=function(a,b){var c=this;return"string"==typeof b&&(b=this[b]),"function"==typeof b?"string"==typeof a?this.router.addRoute(a,b):Array.isArray(a)&&a.forEach(function(a){c.router.addRoute(a,b)}):log.warn("Router callback isn't a function",b,"of route",a),this},
//--
module.exports=Presenter;var XQCore=require("./xqcore-core"),Model=function(a,b){
//Call XQCore.ReadyState constructor
XQCore.ReadyState.call(this),
//Call Event constructor
XQCore.Event.call(this),"object"==typeof arguments[0]&&(b=a,a=b.name),/**
     * Enable debug mode
     * @public
     * @type {Boolean}
     */
this.logLevel=XQCore.logLevel,/**
     * Stores models properties
     * @type {Object}
     * @property properties
     */
this.properties={},/**
     * Contains last validation errors if state is invalid
     * @type {Array}
     * @property lastValidationError
     */
this.lastValidationError=null,
//-- Initial conf mapping
void 0===b&&(b={}),"function"==typeof b?b.call(this,this):XQCore.extend(this,b),this.__state="starting",this.__unfiltered={},this.__isValid=!1,this.customValidate=b.validate,delete b.validate,this.conf=b,/**
     * Model name
     * @property {String} name
     */
this.name=(a?a.replace(/Model$/,""):"Nameless")+"Model",
//-- Add default values
this.defaults&&!XQCore.isEmptyObject(this.defaults)&&this.set(this.defaults,{silent:!0,noValidation:!0}),
//-- Add schema props as default values
this.schema&&Object.keys(this.schema).forEach(function(a){a in this.properties||(this.properties[a]=void 0!==this.schema[a]["default"]?this.schema[a]["default"]:null)},this),this.__isValid=!this.schema,this.state("ready")};
//Extend with ready state
XQCore.extend(Model.prototype,XQCore.ReadyState.prototype),XQCore.extend(Model.prototype,XQCore.Event.prototype),XQCore.extend(Model.prototype,new XQCore.Logger),XQCore.Sync&&XQCore.extend(Model.prototype,XQCore.Sync.prototype),/**
 * Inherits a model prototype
 * @method inherit
 * @static
 * @param  {String} name    model name
 * @param  {Object} options Model properties
 * @return {Object}         Returns a XQCore.Model prototype
 */
Model.inherit=function(a,b){"object"==typeof a&&(b=a,a=void 0);var c=function(c,d){
//TODO call this later, ready state will be set before _options had been run
XQCore.Model.call(this,a,b),c&&("string"==typeof c?a=c:d=c,"function"==typeof d?d.call(this,this):"object"==typeof d&&XQCore.extend(this,d))};return c.prototype=Object.create(XQCore.Model.prototype),c.prototype.constructor=c,c},/**
 * Change the model state
 *
 * @method state
 * @param {String} state New state
 */
Model.prototype.state=function(a){this.__state=a,this.emit("state."+a),this.emit("state.change",a)},/**
 * Get the current model state
 *
 * @method getState
 */
Model.prototype.getState=function(){return this.__state},/**
 * Set model data
 *
 * Triggers a data.change event if data was set succesfully
 *
 * @method set
 * @param {Object} data
 */
/**
 * Set model data
 *
 * Triggers these events if data was set succesfully<br>
 * data.change<br>
 * &lt;key&gt;.change
 *
 * options: {
 *   silent: <Boolean> Don't trigger any events
 *   noValidation: <Boolean> Don't validate
 *   replace: <Boolean> Replace all date with new data
 *   noSync: <Boolean> Do not call sync method. Default: false
 * }
 *
 * @method set
 * @param {String} key
 * @param {Object} value Data value
 * @param {Object} options Options
 *
 * @returns {Object} Returns a promise object
 */
Model.prototype.set=function(a,b,c){var d,e={},f=this.get(),g=!1,h=!1;if(c=c||{},null===arguments[0]?(e=arguments[1],h=!0,this.log("Set data",e,f)):"object"==typeof arguments[0]?(c=b||{},e=c.replace?arguments[0]:XQCore.extend(e,f,arguments[0]),h=!0,a=null,this.log("Set data",e,f)):"string"==typeof arguments[0]?(e=XQCore.extend({},this.get()),g=!0,XQCore.dedotify(e,a,b),this.log("Set value",a,b,f)):this.warn("Data are incorrect in model.set()",arguments),c=c||{},c.noValidation!==!0){if(this.customValidate)this.log("Using a custom validation!"),d=this.customValidate(e);else if(this.schema&&(d=this.validate(e),g&&d)){for(var i,j=0,k=d.length;k>j;j++)if(d[j].property===a){i=[d[j]];break}d=i||null}if(d)return this.warn("Validation error",d),c.silent!==!0&&this.emit("validation.error",d,e),XQCore.Promise.reject({msg:"validation.error",err:d})}
//TODO show only replaced data if set is using
return this.properties=e,c.silent!==!0&&(h?c.noSync||"function"!=typeof this.sync?this.emit(c.replace?"data.replace":"data.set",e,f):this.sync(c.replace?"replace":"set",e):g&&(c.noSync||"function"!=typeof this.sync||this.sync("value",a,b),this.emit("value.set",a,b)),this.emit("data.change",e,f)),XQCore.Promise.resolve(e)},/**
 * Get one or all properties from a dataset
 *
 * <b>Options:</b>
 *   copy: <Boolean>  //Set it to true to get a copy of the dataset
 *
 * @param {String} key Data key
 * @param {Object} options Set options
 *
 * @returns {Object}    Returns the whole model or a filtered dataset
 */
Model.prototype.get=function(key,options){void 0===options&&(options={});var data;if("object"==typeof key&&1===arguments.length&&(options=key,key=null),void 0===key||null===key){if(options.copy===!0)switch(data=this.properties,typeof data){case"object":return Array.isArray(data)?data.slice():XQCore.extend(!0,{},data);case"function":
//jshint evil:true
return eval("("+data.toString()+")");default:return data}return this.properties}if("string"==typeof key&&"number"==typeof options){var index=options;3===arguments.length&&(options=arguments[2]);var item=this.get(key);return options.copy===!0&&"object"==typeof item[index]?XQCore.extend({},item[index]):item?item[index]:null}if(options.copy===!0)switch(data=XQCore.undotify(key,this.properties),typeof data){case"object":return Array.isArray(data)?data.slice():XQCore.extend(!0,{},data);case"function":
//jshint evil:true
return eval("("+data.toString()+")");default:return data}return XQCore.undotify(key,this.properties)},/**
 * Get items filtered by a key array or object
 * @param  {Object|Array} keys Key array
 * @param  {Object} data (Optional) Data to be filtered. Uses model data if it is undefined
 * @return {Object}      Returns a filtered data object
 */
Model.prototype.getByKeys=function(a,b){if("object"!=typeof a)throw new Error("First param must be an object or array in Model.getByKeys()!");var c={};if(b=b||this.get(),Array.isArray(a))a.forEach(function(a){-1===a.indexOf(".")?c[a]=b[a]:c=XQCore.dedotify(c,a,XQCore.undotify(a,b))});else for(var d in a)if(a.hasOwnProperty(d)){var e=b[d];"object"==typeof e?c[d]=this.getByKeys(a[d],b[d]):c[d]=b[d]}return c},/**
 * Check wether model has a dataset
 *
 * @method  has
 * @param {String} key Dataset key
 * @return {Boolean} Returns true if model has a dataset with key
 */
Model.prototype.has=function(a){var b=!0,c=this.properties;a=a.split(".");for(var d=0,e=a.length;e>d;d++){if("object"!=typeof c||!c.hasOwnProperty(a[d])){b=!1;break}c=c[a[d]]}return b},/**
 * Removes all data from model
 *
 * @method reset
 * @param  {Object} options Options object
 * {
 *     removeListener: true,    //Remove all event listener
 *     silent: true,            //Disable event emitting
 *     noSync: true             //Don't call sync method
 * }
 *
 * @fires data.reset
 * Fires a data.reset event if model was succesfully reseted.
 *
 * @returns {Object} Returns removed data
 *
 */
Model.prototype.reset=function(a){a=a||{},this.log("Reset model");var b=this.get();return this.properties=XQCore.extend({},this.defaults),this.state("ready"),a.silent||this.emit("data.reset",b),a.removeListener&&this.clearEvents(),a.noSync||"function"==typeof this.sync&&this.sync("reset",b),b},/**
 * Push data to a subset
 *
 * @method push
 * @param {String} path path to subset
 * @param {Object} data data to add
 */
Model.prototype.push=function(a,b,c){var d=XQCore.undotify(a,this.properties);if(c=c||{},d instanceof Array)d.push(b);else if("undefined"==typeof d)XQCore.dedotify(this.properties,a,[b]);else{if("object"!=typeof d||a||!XQCore.isEmptyObject(this.properties))return void this.error("Model.push requires an array. Dataset isn't an array. Path: ",a);this.properties=[b]}c.silent!==!0&&(c.noSync||"function"!=typeof this.sync||this.sync("insert",a,-1,b),this.emit("item.insert",a,-1,b),this.emit("data.change",this.properties))},/**
 * Unshift data to a subset
 *
 * @method unshift
 * @param {String} path path to subset
 * @param {Object} data data to add
 */
Model.prototype.unshift=function(a,b,c){var d=XQCore.undotify(a,this.properties);if(c=c||{},d instanceof Array)d.unshift(b);else if("undefined"==typeof d)XQCore.dedotify(this.properties,a,[b]);else{if("object"!=typeof d||a||!XQCore.isEmptyObject(this.properties))return void this.error("Model.unshift requires an array. Dataset isn't an array. Path: ",a);this.properties=[b]}c.silent!==!0&&(c.noSync||"function"!=typeof this.sync||this.sync("insert",a,0,b),this.emit("item.insert",a,0,b),this.emit("data.change",this.properties))},/**
 * Insert data into a subset at a given index
 * 
 * @method insert
 * @param {String} path Path to subset
 * @param {Number} index The index where the data should be inserted
 * @param {Object} data Dataset to be inserted
 * @param {Object} options Inserting options
 */
Model.prototype.insert=function(a,b,c,d){var e=XQCore.undotify(a,this.properties);if(d=d||{},e instanceof Array)-1===b?e.push(c):0===b?e.unshift(c):e.splice(b,0,c);else{if(e)return void this.error("Model.insert requires an array. Dataset isn't an array. Path: ",a);XQCore.dedotify(this.properties,a,[c])}d.silent!==!0&&(d.noSync||"function"!=typeof this.sync||this.sync("insert",a,b,c),this.emit("item.insert",a,b,c),this.emit("data.change",this.properties))},/**
 * Remove a subset
 *
 * @method remove
 * @param {String} path path to subset
 * @param {Number} index Index of the subsut to remove
 * @param {Object} options Remove options
 *
 * @return {Object} removed subset
 */
Model.prototype.remove=function(a,b,c){var d=XQCore.undotify(a,this.properties),e=null;if(c=c||{},d instanceof Array)e=d.splice(b,1);else if("object"==typeof d)return void this.error("Model.remove requires an array. Dataset isn't an array. Path: ",a);return e&&c.silent!==!0&&(c.noSync||"function"!=typeof this.sync||this.sync("remove",a,b),this.emit("item.remove",a,b,e[0]),this.emit("data.change",this.properties)),e},/**
 * Replace all models data with new data. This is a alias for set(<AnyData>, {replace: true})
 *
 * @method replace
 * @param {Object} data Data object
 * @param {Object} options Option data. (See set method for details)
 */
Model.prototype.replace=function(a,b){return b=b||{},b.replace=!0,this.set(a,b)},/**
 * Search an item in models properties
 *
 * @method search
 * @param {String} path Path to the parent property. We use dot notation to navigate to subproperties. (data.bla.blub) (Optional)
 * @param {Object} searchfor Searching for object
 * @return {Object} Returns the first matched item or null
 */
Model.prototype.search=function(a,b){var c;if(1===arguments.length?(b=a,a="",c=this.properties):c=a?XQCore.undotify(a,this.properties):this.properties,c)for(var d=0;d<c.length;d++){var e,f=c[d];for(var g in b)if(b.hasOwnProperty(g)){if(f[g]&&f[g]===b[g]){e=!0;break}e=!1}if(e===!0)return f}return null},/**
 * Updates a dataset
 * @development
 * 
 * @method modify
 * @param {String} path Parent path
 * @param {Number|Object} match Search match or index to find the to be modifyd item
 * @param {Object} data Update date
 */
Model.prototype.modify=function(a,b,c,d){var e;d=d||{},e="number"==typeof b?this.get(a,b):this.search(a,b);var f=XQCore.extend({},e);e&&(XQCore.extend(e,c),d.silent!==!0&&(this.emit("data.modify",a,b,c,f),this.emit("data.change",this.properties)),d.noSync||"function"!=typeof this.sync||this.sync("modify",a,b,c))},/**
 * Sort an array collection by a given attribute
 *
 * @method  sortBy
 * @param {String} path Path to the collection
 * @param {Object} sortKeys Sort by key
 *
 * sortKeys: {
 *   'key': 1 // Sort ascend by key,
 *   'second.key': -1 // Sort descand by second.key
 * }
 *
 * ascend, a -> z, 0 - > 9 (-1)
 * descend, z -> a, 9 -> 0 (1)
 * 
 */
Model.prototype.sortBy=function(a,b){1===arguments.length&&(b=a,a=null);var c,d=XQCore.undotify(a,this.properties);return Array.isArray(d)?(d.sort(function(a,d){c=-1;for(var e in b)if(b.hasOwnProperty(e)){if(c=String(XQCore.undotify(e,a)).localeCompare(String(XQCore.undotify(e,d))),0===c)continue;-1===b[e]&&(c=c>0?-1:1);break}return c}),this.set(a,d),d):(this.warn("Could not sort data of type",typeof d),[])},/**
 * Filter an array collection by a given filter function
 *
 * @method filter
 * @param {String} path Path to the collection
 * @param {String | Function} filter Filter function
 *
 */
Model.prototype.filter=function(a,b,c,d){if(1===arguments.length&&(d=a,a=null),"string"==typeof d){if(!this.__registeredFilter[d])throw new Error("Filter "+d+" not registered!");d=this.__registeredFilter[d]}for(var e=XQCore.undotify(a,this.__unfiltered.data||this.properties),f=[],g=0,h=e.length;h>g;g++)d(b,c,e[g])&&f.push(e[g]);return this.__unfiltered={path:a,data:e},this.set(a,f),f},/**
 * Resets a filter
 * @method filterReset
 * @param {Object} options Set options
 */
Model.prototype.filterReset=function(a){this.__unfiltered&&this.set(this.__unfiltered.path,this.__unfiltered.data,a)},/**
 * Validate model
 * @method validate
 * @param {Object} data Data to be validated
 * @param {Object} schema Schema
 * @returns {Object} Returns an object with failed validations or null if validation succeeds
 */
Model.prototype.validate=function(a,b){var c,d=this,e=[];return b=b||this.schema,b&&Object.keys(b).forEach(function(f){if(console.log("KEY",f),"object"==typeof b[f]&&"undefined"==typeof b[f].type)return void(b[f].ref&&b[f].schema?(console.log("Has a subref to %s",b[f].ref),c=d.validate(a,b[f].schema),c&&(e=e.concat(c))):(console.log("SUBVAL"),c=d.validate(XQCore.extend({},a[f]),XQCore.extend({},b[f])),console.log("RES",c),Array.isArray(c)&&c.length>0&&(e=e.concat(c))));var g=d.validateOne(b[f],a[f]);g.isValid===!0?a[f]=g.value:(g.error.property=f,e.push(g.error))}),0===e.length?(this.__isValid=!0,this.lastValidationError=null,this.state("valid"),null):(this.__isValid=!1,this.lastValidationError=e,this.state("invalid"),e)},/**
 * Validate one property
 *
 * ValidatorResultItemObject
 * {
 *   isValid: Boolean,
 *   value: Any,
 *   error: Object
 * }
 *
 * @param  {Any} schema Schema for the check
 * @param  {Any} value Property value
 *
 * @return {Object}       Returns a ValidatorResultItemObject
 */
Model.prototype.validateOne=function(a,b,c){var d,e;if(void 0===a.type){if(!a.ref)throw new Error("No schema type are set!");e="ref"}else e=a.type.toLowerCase();if(""===b&&a.noEmpty===!0&&(b=void 0),void 0!==b&&null!==b&&""!==b||!a["default"]||(b=a["default"]),void 0===b||null===b||""===b)a.required===!0&&(d={msg:"Property is undefined or null, but it's required",errCode:10});else{if(!this.__registeredValidations[e])throw new Error("Undefined schema type",a);d=this.__registeredValidations[e].call(this,b,a)}return d=void 0===d?{isValid:!0,value:b,error:null}:{isValid:!1,value:b,error:d}},/**
 * Checks the validation of a property without changeing any states
 *
 * @method checkValidation
 * @param  {String}  key  Property name
 * @param {String} value Property value
 * @returns {Boolean} Returns true if validation had been passed
 */
Model.prototype.checkValidation=function(a,b){var c=this.validateOne(this.schema[a],b,a);return c.isValid},/**
 * Returns the validation state of the model
 * 
 * @method isValid
 * @returns {Boolean} Returns true when model data are valid. When no data was set it'll returns false
 */
Model.prototype.isValid=function(){return this.__isValid},/**
 * To be called when a form has been submited in a coupled model
 *
 * Model gets <i>submited</i> state when validation succeeds
 * If validation fails, model gets <i>invalid</i> state
 *
 * @deprecated
 * @method setData
 * @param {Object} data Form data
 */
Model.prototype.setData=function(a,b){this.warn("Model.setData has been deprecated since v0.9"),this.set(a,{extend:!0})},/**
 * Register a filter function 
 *
 * XQCore.Model.registerFilter('myfilter', fn);
 * Registers a filter for all models
 *
 * instance.registerFilter('myfilter', fn);
 * Registers a filter for the instance only.
 * 
 * @method registerFilter
 * @param {String} filterName [description]
 * @param {Function} filterFunction [description]
 */
Model.registerFilter=function(a,b){if("function"!=typeof b)throw new Error("Filter function isn't a function");var c="function"==typeof this?Model.prototype:this;c.__registeredFilter[a]=b},/**
 * Alias for Model.registerFilter
 * @type {method}
 */
Model.prototype.registerFilter=Model.registerFilter,/**
 * Holds registered filter
 * @type {Object}
 * @private
 */
Model.prototype.__registeredFilter={quicksearch:function(a,b,c){var d=XQCore.undotify(a,c),e=new RegExp(b.replace(/[a-z0-9äüöß]/g,"$&.*"),"i");return e.test(d)}},/**
 * Register validation metods for all Models
 *
 * @method registerValidation
 * @static
 * @param {String} type Data type
 * @param {Function} fn Validation function
 */
Model.registerValidation=function(a,b){var c="function"==typeof this?Model.prototype:this;c.__registeredValidations[a]=b},/**
 * Register new validation method for currentyl instanciated model
 *
 * @method registerValidation
 * @param {String} type Data type
 * @param {Function} fn Validation function
 */
Model.prototype.registerValidation=Model.registerValidation,/**
 * Stores registered validatiion functions
 * @type {Object}
 * @private
 */
Model.prototype.__registeredValidations={string:function(a,b){return b.convert&&"number"==typeof a&&(a=String(a)),"string"!=typeof a?{msg:"Property type is a "+typeof a+", but a string is required",errCode:11}:b.min&&b.min>a.length?{msg:"String length is too short",errCode:12}:b.max&&b.max<a.length?{msg:"String length is too long",errCode:13}:b.match&&!b.match.test(a)?{msg:"String doesn't match regexp",errCode:14}:void 0},number:function(a,b){return b.convert&&"string"==typeof a&&(a=parseInt(a,10)),"number"!=typeof a||isNaN(a)?{msg:"Property type is not a valid number",errCode:21}:b.min&&b.min>a?{msg:"Number is too low",errCode:22}:b.max&&b.max<a?{msg:"Number is too high",errCode:23}:void 0},date:function(a,b){if(a){var c=Date.parse(a);if(isNaN(c))return{msg:"Property isn't a valid date",errCode:31}}},array:function(a,b){return Array.isArray(a)?b.min&&b.min>a.length?{msg:"Array length is "+a.length+" but must be greater than "+b.min,errCode:42}:b.max&&b.max<a.length?{msg:"Array length is "+a.length+" but must be lesser than "+b.max,errCode:43}:void 0:{msg:"Property type is a "+typeof a+", but an array is required",errCode:41}},object:function(a,b){return"object"!=typeof a?{msg:"Property isn't a valid object",errCode:51}:void 0},objectid:function(a,b){return/^[a-zA-Z0-9]{24}$/.test(a)?void 0:{msg:"Property isn't a valid objectId",errCode:52}},"boolean":function(a,b){return"boolean"!=typeof a?{msg:"Property isn't a valid boolean",errCode:61}:void 0},/**
     * Validation type time
     *
     * Allowed values are:
     * HH:MM
     * HH:MM:SS
     * D:HH:MM:SS
     */
time:function(a,b){return/^\d+(:\d{2}){1,3}$/.test(a)?void 0:{msg:"Property isn't a valid time",errCode:71}},/**
     * Validation type email         *
     */
email:function(a,b){return/^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(a)?void 0:{msg:"Property isn't a valid email",errCode:72}}},/**
 * Returns model as JSON
 * @method toJSON
 * @return {Object} Returns model data as JSON
 */
Model.prototype.toJSON=function(){return this.get()},
//--
module.exports=Model;var XQCore=require("./xqcore-core"),FireTPL=require("firetpl"),Tmpl={type:"firetpl",compile:FireTPL.compile,getTemplate:function(a,b){if(b=b||{},FireTPL.templateCache&&FireTPL.templateCache[a])return FireTPL.templateCache[a];if(FireTPL.loadFile){var c=b.viewDir||XQCore.viewsDir,d=FireTPL.readFile(c.replace(/\/$/,"")+"/"+a+"."+XQCore.viewExt.replace(/^\./,""));return FireTPL.compile(d,{eventAttrs:!0})}throw new Error("FireTPL runtime is being used. Please preload the "+a+"View")}};
//--
module.exports=Tmpl;var XQCore=require("./xqcore-core"),$=require("jquery"),log,View=function(a,b){
//Call Event constructor
XQCore.Event.call(this),"object"==typeof arguments[0]||"function"==typeof arguments[0]?(b=a,a=null):"string"==typeof arguments[0]&&(this.name=a),log=new XQCore.Logger(this.name+"View"),this.container="body",this.tag=void 0,this.className=void 0,this.id=void 0,this.mode="replace",this.autoInject=!0,this.__domReady=!1,this.__viewEvents=[];var c=this;"function"==typeof b?b.call(this,c):XQCore.extend(this,b),/**
     * Set view name
     * @public
     * @type {String}
     */
this.name=(this.name?this.name.replace(/View$/,""):"Nameless")+"View",this.__createView(),$(function(){c.container.length>0?(window.addEventListener("resize",function(a){c.resize(a)},!1),log.info("Initialize view "+this.name," with conf:",b),log.info(" ... using Container:",c.container)):log.error("Can't initialize View, Container not found!",c.container)})};XQCore.extend(View.prototype,XQCore.Event.prototype),/**
 * Show view if it is invisible
 *
 * @method show
 * @param {Boolean} hideOther Hide all other sibling views
 * @chainable
 * @fires view.show Fires a v`view.show` event
 * @returns {Object} Returns this value
 */
View.prototype.show=function(a){var b=this;return a&&b.$ct.children(".xq-view").each(function(){if(this!==b.el){var a=$(this).data("view");a.hide()}}),this.$el.show().removeClass("xq-hidden"),this.emit("view.show"),this},/**
 * Hide view
 * 
 * @method hide
 * @chainable
 * @fires view.hide Fires a v`view.hide` event
 * @return {Object} Returns this value
 */
View.prototype.hide=function(){return this.$el.hide().addClass("xq-hidden"),this.emit("view.hide"),this},/**
 * Marks a view as active, optionally inactivates all other sibling views
 *
 * @method active
 * @param {Boolean} inactivateOther Makes all other sibling views inactive
 * @chainable
 * @fires view.active Fires a v`view.active` event
 * @returns {Object} Returns this value
 */
View.prototype.active=function(a){var b=this;return a&&b.$ct.children(".xq-view").each(function(){if(this!==b.el){var a=$(this).data("view");a.inactive()}}),this.$el.addClass("xq-active").removeClass("xq-inactive"),this.emit("view.active"),this},/**
 * Marks a view as inactive
 * 
 * @method inactivate
 * @chainable
 * @fires view.inactive Fires a v`view.inactive` event
 * @return {Object} Returns this value
 */
View.prototype.inactive=function(){return this.$el.removeClass("xq-active").addClass("xq-inactive"),this.emit("view.inactive"),this},View.prototype.renderHTML=function(a,b){return log.log("Render html snippet",a,"with data:",b),(a="function"==typeof a?a:XQCore.Tmpl.compile(a))(b)},/**
 * To be called if window resizes
 * This is a placeholder method. Override this method if its needed
 *
 * @overridable
 * @return {Object} Returns this value
 */
View.prototype.resize=function(){return this},/**
 * Gets the data of an element
 *
 * @param {Object} selector DOM el or a jQuery selector of the element
 *
 * @return {Object} Returns the data of an element or null
 */
View.prototype.getElementData=function(a){var b=$(a,this.container);if(b.length){var c,d={},e=b.get(0).attributes;for(c=0;c<e.length;c++)if(0===e[c].name.indexOf("data-")){var f=e[c].name.substr(5),g=e[c].value;if("string"==typeof g)try{g="true"===g||"TRUE"===g?!0:"false"===g||"FALSE"===g?!1:"null"===g||"NULL"===g?null:"undefined"===g?void 0:+g+""===g?+g:JSON.parse(g)}catch(h){}d[f]=g}return d}return null},/**
 * If a validation failed (Automatically called in a coupled view)
 *
 * @method validationFailed
 * @param {Object} err Validation error object
 */
View.prototype.validationFailed=function(a,b){var c=this;a.forEach(function(a){c.$el.find('[name="'+a.property+'"]').addClass("xq-invalid")})},/**
 * If a validation succeeds (Automatically called in a coupled view)
 *
 * @method validationSucceeded
 * @param {String} name Input name
 * @param {String} value Input value
 */
View.prototype.validationSucceeded=function(a,b){var c=this;c.$el.find('[name="'+a+'"]').removeClass("xq-invalid")},/**
 * To be called when a state.change event from a coupled model was revived
 *
 * @param {String} state Model state
 * @override
 */
View.prototype.onStateChange=function(a){if(!this.el)return void(this.__initialState=a);var b=this.el.className.split(" ");b=b.filter(function(a){return!/^xq-state-/.test(a)}),b.push("xq-state-"+a),this.el.className=b.join(" ")},/**
 * Wait till view is ready
 *
 * @method ready
 * @param {Function} callback Callback
 */
View.prototype.ready=function(a){this.isReady?a.call(this):(this.__readyCallbacks||(this.__readyCallbacks=[]),this.__readyCallbacks.push(a))},View.prototype.__setReadyState=function(){var a=this;this.isReady=!0,this.__readyCallbacks&&(this.__readyCallbacks.forEach(function(b){b.call(a)}),this.__readyCallbacks=[])},/**
 * Inject element into the DOM
 *
 * @public
 * @method inject
 */
View.prototype.inject=function(){var a=this.isElementInDOM(this.ct);if(this.el.parentNode!==this.ct||!a)if(a||(this.$ct=$(this.container),this.ct=this.$ct.get(0)),log.info("Inject view into container",this.$ct),"replace"===this.mode){var b=this.$ct.contents();b.each(function(){var a=$(this).data("view");a?a.detach():$(this).detach()}),
// this.$ct.contents().detach();
this.$ct.append(this.$el)}else if("append"===this.mode)this.$ct.append(this.$el);else{if("prepend"!==this.mode)throw new Error("Unknown insert mode in view constructor");this.$ct.prepend(this.$el)}},/**
 * Parse a precompiled template and returns a html string
 *
 * @method parse
 *
 * @param {Function} template Precompiled template
 * @param {Object} data Data object
 *
 * @return {String} compiled html
 */
View.prototype.parse=function(a,b,c){var d,e;a.scopeStore={},a.scopes=c||{};try{d=a(b||{},a.scopes)}catch(f){d='<p class="renderError"><b>View render error!</b><br>'+f.message+"</p>",log.error("View render error!",f)}var g=function(b,c,d){b=$.parseHTML(b);var e=$(b),f=e.find("scope"),h={};return f.each(function(){var b,e=$(this).attr("id"),f=$(this).attr("path"),i=d?d+"."+f:f,j=c;if(Array.isArray(c)&&(h[f]=h[f]||0,j=c[h[f]++]),b={},e){var k=a.scopes[e](c[f],c);b.value=k?g(k,c[f],i):document.createTextNode(""),b.id=e}else b.value=$.parseHTML(c[f]);a.scopeStore[i]=a.scopeStore[i]||[],a.scopeStore[i].push(b),$(this).replaceWith($(b.value))}),e};return d&&(e=g(d,b)),e},/**
 * Render view
 *
 * @method render
 * @chainable
 * @emits content.change
 *
 * @param  {Object} data Render data
 * @returns {Object} Returns this value
 */
View.prototype._render=function(a){if(this.__domReady===!1)return this.__initialData=a||{},this;this.autoInject&&this.inject();var b;log.info("Render view template of view "+this.name,"with data:",a);var c="function"==typeof this.template?this.template:XQCore.Tmpl.compile(this.template);this.scopes={};try{b=c(a||{},this.scopes)}catch(d){b='<p class="renderError"><b>View render error!</b><br>'+d.message+"</p>",log.error("View render error!",d)}return this.el.innerHTML=b,this.emit("content.change",a),this.registerListener(this.$el),this.registerForms(),this},/**
 * Render view
 *
 * @method render
 * @chainable
 * @emits content.change
 *
 * @param  {Object} data Render data
 * @returns {Object} Returns this value
 */
View.prototype.render=function(a){if(this.__domReady===!1)return this.__initialData=a||{},this;this.autoInject&&this.inject();var b;log.info("Render view template of view "+this.name,"with data:",a);var c="function"==typeof this.template?this.template:XQCore.Tmpl.compile(this.template);this.scopes={dataFn:function(a,b){var c=b[a];return(null===c||void 0===c)&&(c=""),'<ftl path="'+a+'">'+c+"</ftl>"},scopeFn:function(a,b,c){return"data"===b&&Array.isArray(c)&&(b="_ftl_root"),'<ftl scope="'+a+'" path="'+b+'"></ftl>'},attrFn:function(a,b){var c=b.replace(/<ftl path="([a-zA-Z0-9_.-]+)">(.+?)<\/ftl>/g,function(a,b,c){return c}),d=b.replace(/<ftl path="([a-zA-Z0-9_.-]+)">(.+?)<\/ftl>/g,function(a,b,c){return"%s"}),e=a+'="'+c+'" xq-'+a+'="'+d+'"';return e}};try{b=c(a||{},this.scopes)}catch(d){b='<p class="renderError"><b>View render error!</b><br>'+d.message+"</p>",log.error("View render error!",d)}this.el.innerHTML=b;var e=this;
//Replace scopes
return this.scopesMap={},this.$el.find("ftl").each(function(){var b=$(this).attr("scope"),c=$(this).attr("path");b?e.replaceScopes($(this),b,a,c,c):e.replaceNode($(this),c)}),this.emit("content.change",a),this.registerListener(this.$el),this.registerForms(),this},View.prototype.replaceScopes=function(a,b,c,d,e){var f=this,g=d&&"_ftl_root"!==d?c[d]:c,h=f.scopes[b](g,c),i=$($.parseHTML(h)),j=a.parent();if(
//Replace scopes
i.find("ftl").each(function(){var a=$(this).attr("scope"),b=$(this).attr("path");a?f.replaceScopes($(this),a,g,b,e+(Array.isArray(g)?"[].":".")+b):f.replaceNode($(this),e+(Array.isArray(g)?"[].":".")+b)}),a.replaceWith(i),-1===e.indexOf("[].")){e in f.scopesMap||(f.scopesMap[e]=[]);var k=function(a){if(!Array.isArray(g))return[a];var b=a.length/g.length,c=[],d=[];return a.each(function(){d.push($(this).get(0)),d.length===b&&(c.push(d),d=[])}),c};f.scopesMap[e].push({type:"scope",fn:f.scopes[b],childs:k(i,g),parentData:c,parent:j})}},View.prototype.replaceNode=function(a,b){var c=this,d=a.html(),e=document.createTextNode(d);a.replaceWith(e),-1===b.indexOf("[].")&&(b in c.scopesMap||(c.scopesMap[b]=[]),c.scopesMap[b].push({type:"node",node:e}))},View.prototype.renderScope=function(a,b,c){var d=this,e=$.parseHTML(a.fn(c,a.parentData)),f=$(e);return f.find("ftl").each(function(){var a=$(this).attr("scope"),b=$(this).attr("path");a?d.replaceScopes($(this),a,c,b,b):d.replaceNode($(this),b)}),this.registerListener(f),f},View.prototype.renderNode=function(a,b,c){a.node.nodeValue=c},View.prototype.registerListener=function(a){var b=this;a.find("[on]").addBack("[on]").each(function(){var a,c=$(this),d=$(this).attr("on"),e=$(this).data();c.removeAttr("on"),d=d.split(";"),d.forEach(function(d){d=d.split(":"),a="submit"===d[0]?function(a){a.preventDefault(),e=b.serializeForm(a.target),e=b.onSubmit(e,a.target),b.emit(d[1],e,a)}:function(a){var c;a.originalEvent instanceof KeyboardEvent?c={key:a.key,code:a.keyCode,alt:a.altKey,ctrl:a.ctrlKey,meta:a.metaKey,shift:a.shiftKey}:a.originalEvent instanceof MouseEvent?(a.preventDefault(),c={button:a.button,alt:a.altKey,ctrl:a.ctrlKey,meta:a.metaKey,shift:a.shiftKey},"click"===a.type&&a.currentTarget.href&&(c.href=a.currentTarget.href)):(a.preventDefault(),c=a.currentTarget.value||""),b.emit(d[1],c,e,a)},c.bind(d[0],a)})})},/**
 * Serialize a form and return its values as JSON
 *
 * @param {Object} Form selector
 * @return {Object} FormData as JSON
 */
View.prototype.serializeForm=function(a){var b={},c=$(a);return"INPUT"!==c.get(0).tagName&&(c=c.find(":input")),c.serializeArray().forEach(function(a){XQCore.dedotify(b,a.name,a.value)}),log.info("Serialize form of view "+this.name,"form selector:",c,"form data:",b),b},/**
 * Insert a subset
 * @param  {String} path  Data path
 * @param  {Number} index Index after which item the insert should be happen or use -1 to prepend
 * @param  {Object} data  Item data
 */
View.prototype.insert=function(a,b,c){var d=this;a in this.scopesMap&&this.scopesMap[a].forEach(function(e){var f=d.renderScope(e,a,[c]);if(-1===b)e.parent.append(f),e.childs.push([f.get()]);else if(0===b)e.parent.prepend(f),e.childs.unshift([f.get()]);else{var g=e.childs[b];$(g[0]).before(f);var h=[b,0].concat([f.get()]);e.childs.splice.apply(e.childs,h)}})},View.prototype.update=function(a,b){log.warn("XQCore doesn`t support update events yet")},View.prototype.append=function(a,b){1===arguments.length&&(b=a,a="data"),this.insert(a,-1,b)},View.prototype.prepend=function(a,b){1===arguments.length&&(b=a,a="data"),this.insert(a,0,b)},/**
 * Remove an item from a subset. Removes the item with the given index.
 * If index is negative number it will be removed from the end
 * 
 * @param  {String} path  data path
 * @param  {Number} index Index of the item
 */
View.prototype.remove=function(a,b){a in this.scopesMap&&this.scopesMap[a].forEach(function(a){var c=a.childs[b];Array.isArray(c)?c.forEach(function(a){$(a).remove()}):$(c).remove(),a.childs.splice(b,1)})},View.prototype.removeLast=function(a){log.warn("XQCore doesn`t support pop events yet")},View.prototype.removeFirst=function(a){log.warn("XQCore doesn`t support shift events yet")},View.prototype.change=function(a,b){var c=this;this.ready(function(){a in this.scopesMap&&this.scopesMap[a].forEach(function(d){"node"===d.type&&c.renderNode(d,a,b)})})},/**
 * Seting up forms
 * It's wating till view is ready
 * @param  {Object} model Coupled model
 * @param  {Object} $el   Form element
 */
View.prototype.formSetup=function(a,b){var c=this;this.ready(function(){
// var errClassName = 'xq-invalid',
// disabledClass = 'xq-disabled';
// if (!$el) {
//     $el = this.$el.find('form');
// }
var a=function(a){var b=a.target.value,d=a.target.name;c.emit("input.change",d,b)},b=function(a){var b=a.target.value,d=a.target.name;c.emit("input.edit",d,b)},d=function(a){a.preventDefault();var b=c.serializeForm(a.target);c.emit("form.submit",b)};this.addEvent(":input","change",a),this.addEvent(":input","keyup",b),this.addEvent("form","submit",d)})},/**
 * Called on submiting a form. 
 * 
 * @method onSubmit
 * @param {Object} data Form data
 * @param {Object} $form jQuery selector of the submited form
 * @returns {Object} Changed form data
 */
View.prototype.onSubmit=function(a,b){return a},/**
 * Removes a view from dom but does not unreister its DOM event listener.
 * This is usefull if you wish to add this view later back into the DOM.
 * Uncouples itself from a coupled model or list.
 *
 * @method  detach
 *
 * @fires view.detach Fires a `view.detach` event before view is removing from dom.
 * @return {[type]} [description]
 */
View.prototype.detach=function(){log.info("Destroy view"),this.emit("view.detach"),this.$el.detach(),this.__coupled&&(
//Uncouple other participate
this.__coupled.obj.__coupled&&this.__coupled.obj.__coupled.obj===this&&this.__coupled.obj.__coupled.uncouple(),this.__coupled.uncouple()),
//TODO remove all events
log.info("View "+this.name+" has been destroyed")},/**
 * Removes a view from dom and unregisters all its listener
 *
 * @fires view.destroy Fires a `view.destroy` event before view is removing from dom.
 * @return {[type]} [description]
 */
View.prototype.destroy=function(){log.info("Destroy view"),this.emit("view.destroy"),this.$el.remove(),this.__coupled&&(
//Uncouple other participate
this.__coupled.obj.__coupled&&this.__coupled.obj.__coupled.obj===this&&this.__coupled.obj.__coupled.uncouple(),this.__coupled.uncouple()),
//TODO remove all events
log.info("View "+this.name+" has been destroyed")},/**
 * Register a DOM event listerner for a given element. The DOM element mustnt exists at this time. (Using jQuery.deleget() on the this.$el element)
 * @param {String}   selector A selector to the item that should trigger the event
 * @param {String}   events   A string of on ore more Javascript event handler. Use a space separated list for mor then one event. E.g: 'click mousedown'
 * @param {Function} callback Callback function to be called when event is triggered
 */
View.prototype.addEvent=function(a,b,c){this.__viewEvents.push({events:b,selector:a,callback:c}),this.$el&&this.$el.delegate(a,b,c)},/**
 * Defines a container -> view tag type mapping
 * 
 * @private true
 * @type {Object}
 */
View.prototype.__viewTagTypes={"*":"div",body:"section",section:"section",ul:"li",table:"tbody",tbody:"tr",tr:"td"},/**
 * Creates new view element, based on *tag* option
 * 
 * @private true
 * @return {object} Returns a DOM element
 */
View.prototype.__createViewElement=function(){if(this.tag)return document.createElement(this.tag);var a=this.ct?this.ct.tagName.toLowerCase():"*",b=this.__viewTagTypes["*"];return this.__viewTagTypes[a]&&(b=this.__viewTagTypes[a]),document.createElement(b)},/**
 * Creates a view and registers event listeners as soon as DOM is ready.
 *
 * @private true
 */
View.prototype.__createView=function(){var a=this,b=[];$(function(){
//Create view element
a.$ct=a.$ct||$(a.container),a.ct=a.$ct.get(0),a.el=a.__createViewElement(),a.$el=$(a.el),a.$el.data("view",a),b.push("xq-view xq-"+a.name.replace(/View$/,"-view").toLowerCase()),a.id&&a.el.setAttribute("id",a.id),a.className&&b.push(a.className),a.hidden===!0&&(b.push("xq-hidden"),a.$el.hide()),a.el.className=b.join(" "),
//Set DOM ready state
a.__domReady=!0,a.__initialData&&(a.render(a.__initialData),delete a.__initialData),
// if (self.autoInject) {
//     self.inject();
// }
//Set ready state
a.__setReadyState(),a.registerListener(a.$el),
//Register view listener
XQCore.html5Routes&&a.$el.on("click","a",function(b){/^http(s)?:\/\//.test(b.currentTarget.href)||/^\/?[a-z]/.test(b.currentTarget.href)&&(b.preventDefault(),b.stopPropagation(),a.emit("xqcore.navigate",b.currentTarget.href))}),a.forms&&a.formSetup(),a.__initialState&&(a.onStateChange(a.__initialState),delete a.__initialState)})},View.prototype.registerForms=function(){if(this.forms){var a="form";"string"==typeof this.forms&&(a=this.forms),this.ready(function(){this.$forms=this.$el.find(a),this.$forms.addClass("xq-forms"),this.$forms.find(":input").addClass("xq-input")})}},/**
 * Checks whether an element is in the DOM or not.
 *
 * @private
 * @param  {Object}  el DOM element wich sholld be checked
 * @return {Boolean}    Returns true if element is still in the DOM
 */
View.prototype.isElementInDOM=function(a){for(;a;){if(a===document.body)return!0;a=a.parentNode}return!1},
//--
module.exports=View;var XQCore=require("./xqcore-core"),$=require("jquery"),log=new XQCore.Logger("Router"),pathToRegExp=function(a,b){return a=a.concat("/?").replace(/\/\(/g,"(?:/").replace(/(\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?|\*/g,function(a,c,d,e,f,g){return"*"===a?(b.push(void 0),a):(b.push(e),c=c||"",""+(g?"":c)+"(?:"+(g?c:"")+(d||"")+(f||"([^/]+?)")+")"+(g||""))}).replace(/([\/.])/g,"\\$1").replace(/\*/g,"(.*)"),new RegExp("^"+a+"$","i")},Route=function(a){var b,c,d=[];return log.logLevel=XQCore.logLevel,a instanceof RegExp?(c=a,b=a.toString()):(c=pathToRegExp(a,d),b=a),{re:c,src:a.toString(),keys:d}},match=function(a,b,c){for(var d,e=c||0,f=a.length;f>e;++e){var g=a[e],h=g.re,i=g.keys,j=[],k={};if(d=b.match(h)){for(var l=1,m=d.length;m>l;++l){var n=i[l-1],o="string"==typeof d[l]?unescape(d[l]):d[l];n?k[n]=o:j.push(o)}return{params:k,splats:j,route:g.src,next:e+1}}}},Router=function(a){a=a||{},this.routes=[],this.routeMap={},a.noListener||this.registerListener();var b=this;$(function(){
//Call current page
b.callRoute(b.getPath(),{initialCall:!0})})},instance;/**
 * Returns a singelton instance of XQCore.Router
 * @return {[type]} [description]
 */
Router.getInstance=function(){return instance||(instance=new XQCore.Router),instance},Router.prototype.registerListener=function(){XQCore.html5Routes?window.addEventListener("popstate",this.onPopStateHandler.bind(this)):window.addEventListener("hashchange",this.onPopStateHandler.bind(this))},Router.prototype.onPopStateHandler=function(a){var b=this.getPath();this.callRoute(b,{noPush:!0})},Router.prototype.getPath=function(){var a;return XQCore.html5Routes?(a=location.pathname,a.replace(new RegExp("^"+XQCore.basePath),"")):(a=location.hash,a=a.replace(new RegExp("^"+XQCore.hashBang),""),a="/"+a)},/**
 * Registers a new route
 *
 * @method addRoute
 * @param {String}   path Route path
 * @param {Function} fn   Function to be called when addRoute will be called
 * @returns {Object} Returns this value
 * @chainable
 */
Router.prototype.addRoute=function(a,b){if(log.info("Register new route:",a,b),!a)throw new Error(" route requires a path");if(!b)throw new Error(" route "+a.toString()+" requires a callback");if(this.routeMap[a])throw new Error("path is already defined: "+a);"string"==typeof a&&(a=a.replace(/\/$/,""),"/"!==a.charAt(0)&&(a="/"+a));var c=new Route(a);return c.fn=b,this.routes.push(c),this.routeMap[a]=b,this},/**
 * Removes a route
 *
 * @method removeRoute
 * @param  {String} path Path to be removed
 * @return {Object}      Returns this value
 * @chainable
 */
Router.prototype.removeRoute=function(a){if(!a)throw new Error(" route requires a path");if(!this.routeMap[a])return log.warn("Can not remove route! Route does not exists: "+a),this;for(var b=0;b<this.routes.length;b++){var c=this.routes[b];c.src===a&&this.routes.splice(b,1)}return delete this.routeMap[a],this},Router.prototype.match=function(a,b){var c=match(this.routes,a,b);return c&&(c.fn=this.routeMap[c.route],c.next=this.match.bind(this,a,c.next)),c},/**
 * Calls a route
 *
 * Options:
 * --------
 * **noRoute** Doesn't add a push state item
 * **replace** Add a replace state item
 * 
 *
 * @method callRoute
 * @param  {String} path Route path
 * @param {Object} [options] Set options for route call
 * 
 */
Router.prototype.callRoute=function(a,b){if(b=b||{},log.info("Call route",a),void 0===a)throw new Error("XQCore.Router error! Path is undefined in callRoute()!");var c=this.match(a);if(!c)return void log.warn("Could not call any route! No route were found! Called path: "+a);c.path=a,c.initialCall=!!b.initialCall,!XQCore.html5Routes||b.noPush||b.replace?XQCore.html5Routes&&b.replace&&history.replaceState(null,"",a):history.pushState(null,"",a);var d=function(){log.info("... trigger route",this.route,this.fn,this.next),this.fn.call(this,this.params,this.splats,function(){var a=this.next();a&&d.call(a)}.bind(this))};d.call(c)},module.exports=Router;var XQCore=require("./xqcore-core"),SockJS=require("sockjs"),log=new XQCore.Logger("SocketConnection"),instances={},SocketConnection=function(a){
//Only one instance per socket server
/**
     * Holds all registered channels
     * @type {Object} __channels
     */
/**
     * Holds the SockJS instance
     * @private
     * @type {Object} SockJS instance
     */
/**
     * Reconnect if connection gets lost
     * @property {Boolean} autoReconnect
     */
/**
     * Defines a reconnection interval
     * @type {Number}
     */
return instances[a]?instances[a]:(instances[a]=this,this.__isReady=!1,this.__onReadyCallbacks=[],this.__channels={},this.conn=null,this.connect(a),this.autoReconnect=!0,void(this.reconnectionInterval=1500))};/**
 * Connects to a socket server
 * @param  {String} url Socket server url
 */
SocketConnection.prototype.connect=function(a){var b=this;this.conn&&"disconnected"!==this.connectionState||(log.info("Connect to socket server ",a),this.conn=new SockJS(a,null,{debug:log.logLevel>=4}),this.connectionState="connecting",this.conn.onopen=function(){log.info("Connection was successful!"),b.setReady(),b.connectionState="connected"},this.conn.onmessage=function(a){var c;try{c=JSON.parse(a.data)}catch(d){console.error("Could not parse socket message!",a.data)}if(!c.channel)throw new Error("No socket channel was sent!");log.info("Got socket message",c.eventName,"in channel "+c.channel,c.args);var e=c.args||[];e.unshift(c.eventName),b.__channels[c.channel]?b.__channels[c.channel].emit.apply(b.__channels[c.channel],e):log.info(" ... channel not found!",c.channel)},this.conn.onclose=function(c){b.connectionState="disconnected",b.unsetReady(),log.warn("Connection to "+a+" closed!",c),b.autoReconnect&&(log.info("Try to reconnect to "+a),setTimeout(function(){b.connect(a)},b.reconnectionInterval))})},/**
 * Register a channel
 * @param  {String} channel  Channel name
 * @param  {Object} listener Socket object
 */
SocketConnection.prototype.registerChannel=function(a,b){log.info("Register new channel",a),this.__channels[a]?log.info(" ... channel already registered!"):this.__channels[a]=b},/**
 * Unregister a channel
 * @param  {String} channel  Channel name
 * @param  {Object} listener Socket object
 */
SocketConnection.prototype.unregisterChannel=function(a){log.info("Unregister channel",a),this.__channels[a]?delete this.__channels[a]:log.info(" ... channel not found!")},/**
 * Sends a socket message to a connected socket server
 *
 * @method send
 * @param {String} channel   Channel name
 * @param {String} eventName Event name
 * @param {Object} data      Data
 * 
 */
SocketConnection.prototype.send=function(a,b,c){var d=this,e=Array.prototype.slice.call(arguments,2);this.ready(function(){log.info("Send socket message to channel "+a,b,e),d.conn.send(JSON.stringify({channel:a,eventName:b,args:e}))})},/**
 * Call function fn when socket is connected
 *
 * @method ready
 * @param  {Function} fn Function to be called if socket is ready
 */
SocketConnection.prototype.ready=function(a){this.__isReady?a.call(this):this.__onReadyCallbacks.push(a)},/**
 * Sets readyState and calls all queued functions
 *
 * @method setReady
 * @private
 */
SocketConnection.prototype.setReady=function(){var a=this;this.__isReady=!0,this.__onReadyCallbacks.forEach(function(b){b.call(a)}),this.__onReadyCallbacks=[]},SocketConnection.prototype.unsetReady=function(){this.__isReady=!1},
//--
module.exports=SocketConnection;var XQCore=require("./xqcore-core"),log=new XQCore.Logger("Socket");log.logLevel=5;/**
 * Socket connection module
 * @param {String} url     Socket server uri
 * @param {String} channel Socket channel
 *
 * 
 * @example {js}
 * var socket = new XQCore.Socket('http://mysocket.io:9889', 'mychannel');
 * socket.on('data', function() {
 *   console.log('Got data from server');
 * });
 */
var Socket=function(a,b){
//Call Event constructor
XQCore.Event.call(this),this.__isReady=!1,this.__onReadyCallbacks=[],this.channel=b,this.socket=new XQCore.SocketConnection(a),this.socket.registerChannel(b,this)};XQCore.extend(Socket.prototype,XQCore.Event.prototype),/**
 * Sends a socket message to a connected socket server
 *
 * @method send
 * @param {String} eventName Event name
 * @param {Object} data      Event data, multiple args are allowed
 */
Socket.prototype.send=function(a,b){var c=Array.prototype.slice.call(arguments);c.unshift(this.channel),this.socket.send.apply(this.socket,c)},module.exports=Socket;var XQCore=require("./xqcore-core"),SyncModel=function(a,b){/**
     * @property {Boolean} noAutoRegister Disables auto registration. SyncList.register() must be called manually to register the list at the socket server.
     */
this.noAutoRegister=!1,
//Call XQCore.Model constructor
XQCore.Model.call(this,a,b),this.server=this.server||location.protocol+"//"+location.hostname,this.port=this.port||XQCore.socketPort,this.path=this.path||"xqsocket",this.channel=this.channel||this.name.toLowerCase(),this.syncEnabled=!1,this.connectToSocket(),this.noAutoRegister||this.register()};SyncModel.prototype=Object.create(XQCore.Model.prototype),SyncModel.prototype.constructor=SyncModel,/**
 * Inherits a sync model prototype
 * @method inherit
 * @param  {String} name    model name
 * @param  {Object} options SyncModel properties
 * @return {Object}         Returns a XQCore.SyncModel prototype
 */
SyncModel.inherit=function(a,b){"object"==typeof a&&(b=a,a=void 0);var c=function(){XQCore.SyncModel.call(this,a,b)};return c.prototype=Object.create(XQCore.SyncModel.prototype),c.prototype.constructor=c,c},/**
 * Connect to a socket server
 *
 * @method connectToSocket
 */
SyncModel.prototype.connectToSocket=function(){var a=this.server+":"+this.port+"/"+this.path;this.socket||(this.debug("Connect to socket:",a),this.socket=new XQCore.Socket(a,this.channel))},SyncModel.prototype.register=function(a){var b=this;this.syncEnabled=!!a,b.debug("Register syncmodel at server:",b.name);var c={noSync:!0};b.socket.on("syncmodel.set",function(a){b.set(a,c)}),b.socket.on("syncmodel.replace",function(a){c.replace=!0,b.set(a,c)}),b.socket.on("syncmodel.item",function(a,d){b.set(a,d,c)}),b.socket.on("syncmodel.insert",function(a,d,e){b.insert(a,d,e,c)}),b.socket.on("syncmodel.remove",function(a,d,e){b.remove(a,d,e,c)}),b.socket.on("syncmodel.reset",function(){b.reset(c)}),b.socket.on("syncmodel.init",function(a){console.log("Got initial data request:",a),b.set(a,c)}),b.socket.send("syncmodel.register",{name:b.name})},SyncModel.prototype.unregister=function(){var a=this.conf.syncWith||this.name.replace(/Model$/,"");this.socket.send("syncmodel.unregister",{name:a}),this.socket.off("syncmodel.set"),this.socket.off("syncmodel.replace"),this.socket.off("syncmodel.item"),this.socket.off("syncmodel.insert"),this.socket.off("syncmodel.remove"),this.socket.off("syncmodel.reset"),this.socket.off("syncmodel.init")},/**
 * Send a socket message to the server
 * @param  {String} eventName Event name
 * @param  {Object} data      Data object
 */
SyncModel.prototype.emitRemote=function(a,b){this.socket.send(a,b)},SyncModel.prototype.sync=function(a){if(this.syncEnabled){var b=Array.prototype.slice.call(arguments,1);b.unshift("syncmodel."+a),this.emitRemote.apply(this,b)}},SyncModel.prototype.fetchModel=function(){this.emitRemote("syncmodel.fetch")},module.exports=SyncModel;var XQCore=require("./xqcore-core"),List=function(a,b){
//Call XQCore.ReadyState constructor
XQCore.ReadyState.call(this),
//Call Event constructor
XQCore.Event.call(this);var c=this;"object"==typeof arguments[0]&&(b=a,a=b.name),/**
     * Enable debug mode
     * @public
     * @type {Boolean}
     */
this.debug=XQCore.debug,void 0===b&&(b={}),this.__unfiltered={},/**
     * List name
     * @property {String} name
     */
this.name=(a?a.replace(/List$/,""):"Nameless")+"List",/**
     * Contains list items
     * @property {Array} items
     */
this.items=[],/**
     * Sets a maxlength of items
     * @property {Number} maxlength
     * @default null
     */
this.maxLength=null,/**
     * Sets the Model to be used to create new models in push and unshift methods.
     * @property {Object} model
     */
this.model||(this.model=XQCore.Model),/*!
     * Mapping of initial conf
     */
"function"==typeof b?b.call(this,c):XQCore.extend(this,b),/**
     * Sets default values
     * @property {Object|Array} defaults
     */
this.defaults&&!XQCore.isEmpty(this.defaults)&&this.push(this.defaults,{silent:!0,noValidation:!0}),/*!
     * Sets ready state
     */
this.state("ready"),this.setReady()};
//Extend with ready state
XQCore.extend(List.prototype,XQCore.ReadyState.prototype),XQCore.extend(List.prototype,XQCore.Event.prototype),XQCore.extend(List.prototype,new XQCore.Logger),XQCore.Sync&&XQCore.extend(List.prototype,XQCore.Sync.prototype),/**
 * Inherits a list prototype
 * @method inherit
 * @param  {String} name    list name
 * @param  {Object} options Model properties
 * @return {Object}         Returns a XQCore.Model prototype
 */
List.inherit=function(a,b){"object"==typeof a&&(b=a,a=void 0);var c=function(){XQCore.List.call(this,a,b)};return c.prototype=Object.create(XQCore.List.prototype),c.prototype.constructor=c,c},/**
 * Contains the length of the list
 * @property length
 * @type {Number}
 */
Object.defineProperty(List.prototype,"length",{get:function(){return this.items.length}}),/**
 * Change the list state
 *
 * @method state
 * @param {String} state New state
 */
List.prototype.state=function(a){this.__state=a,this.emit("state."+a),this.emit("state.change",a)},/**
 * Get the current list state
 *
 * @method getState
 */
List.prototype.getState=function(){return this.__state},/**
 * Adds one ore more items to the end of a list.
 * You can pass a XQCore.Model or a plain data object.
 * A data object will be converted into a XQCore.Model.
 * The model must be valid to be added to the list.
 * 
 * @param {Object|Array} data Model instance or a plain data object. Add multiple models by using an array of items
 * @param {Object} options Options object
 * {
 *     silent: true,    //Disable event emitting
 *     noSync: true     //Don't call sync method
 * }
 *
 * @returns {Boolean} Returns true if validation was succesfully and all items were added
 */
List.prototype.push=function(a,b){var c,d,e=[];b=b||{},Array.isArray(a)||(a=[a]);for(var f=0,g=a.length;g>f;f++){if(d=a[f],d instanceof XQCore.Model?c=d:(c=new this.model("ListItem"),c.set(d,{noSync:!0,silent:!0})),!c.isValid())return!1;e.push(c)}
//No validation error has been ocured.
var h=this.items.push.apply(this.items,e);return h&&(this.maxLength&&this.items.length>this.maxLength&&this.items.splice(0,this.items.length-this.maxLength),b.silent||this.emit("item.push",e,h),b.noSync||"function"==typeof this.sync&&this.sync("push",e)),!0},/**
 * Adds one ore more items to the beginning of a list.
 * You can pass a XQCore.Model or a plain data object.
 * A data object will be converted into a XQCore.Model.
 * The model must be valid to be added to the list.
 * 
 * @param {Object|Array} data Model instance or a plain data object. Add multiple models by using an array of items
 * @param {Object} options Options object
 * {
 *     silent: true,    //Disable event emitting
 *     noSync: true     //Don't call sync method
 * }
 * @returns {Boolean} Returns true if validation was succesfully and all items were added
 */
List.prototype.unshift=function(a,b){var c,d,e=[];b=b||{},Array.isArray(a)||(a=[a]);for(var f=0,g=a.length;g>f;f++){if(d=a[f],d instanceof XQCore.Model?c=d:(c=new this.model("ListItem"),c.set(d,{noSync:!0,silent:!0})),!c.isValid())return!1;e.unshift(c)}
//No validation error has been ocured.
var h=this.items.unshift.apply(this.items,e);return h&&(this.maxLength&&this.items.length>this.maxLength&&this.items.splice(this.maxLength),b.silent||this.emit("item.unshift",e,h),b.noSync||"function"==typeof this.sync&&this.sync("unshift",e)),!0},/**
 * Removes the last item from a list and returns it.
 *
 * @event item.remove Emits an item.remove event. The removed item will be passed as the first argument
 * 
 * @param {Object} options Options object
 * {
 *     silent: true,    //Disable event emitting
 *     noSync: true     //Don't call sync method
 * }
 *
 * @returns {Object} Returns the removed item
 */
List.prototype.pop=function(a){var b;return a=a||{},b=this.items.pop()||null,void 0===b?null:(a.silent||this.emit("item.pop",b),a.noSync||"function"==typeof this.sync&&this.sync("pop",b),b)},/**
 * Removes the first item from a list and returns it.
 *
 * @event item.shift Emits an item.shift event. The removed item will be passed as the first argument
 * 
 * @param {Object} options Options object
 * {
 *     silent: true,    //Disable event emitting
 *     noSync: true     //Don't call sync method
 * }
 *
 * @returns {Object} Returns the removed item
 */
List.prototype.shift=function(a){var b;return a=a||{},b=this.items.shift()||null,void 0===b?null:(a.silent||this.emit("item.shift",b),a.noSync||"function"==typeof this.sync&&this.sync("shift",b),b)},/**
 * Updates a list item or pushs it to the end
 * You can pass a XQCore.Model or a plain data object.
 * A data object will be converted into a XQCore.Model.
 * The model must be valid to be added to the list.
 *
 * @param {Object|Number} match Match to find element which should be updated
 * @param {Object} data Model instance or a plain data object.
 * @param {Object} options Options object
 * {
 *     silent: true,    //Disable event emitting
 *     noSync: true     //Don't call sync method
 * }
 *
 * @fires item.update
 * Fires an item.update event if item was succesfully updated. Othwewise fires an item.push event
 *
 * @returns {Object} Returns the updated item
 */
List.prototype.update=function(a,b,c){c=c||{};var d;return d="number"==typeof a?this.items[a]:this.findOne(a),d&&(d.set(b,{noSync:!0,silent:!0}),c.silent||this.emit("item.update",d),c.noSync||"function"==typeof this.sync&&this.sync("update",a,b)),d},/**
 * Removes an item at a given position
 *
 * @param {Object|Number} match Match to find element which should be removed
 * @param {Object} options Options object
 * {
 *     silent: true,    //Disable event emitting
 *     noSync: true     //Don't call sync method
 * }
 *
 * @fires item.remove
 * Fires an item.remove event if item was succesfully removed.
 *
 * @returns {Object} Returns the removed item
 */
List.prototype.remove=function(a,b){b=b||{};var c,d=0;if("number"==typeof a)c=this.items[a],d=a;else{c=this.findOne(a);for(var e=0,f=this.items.length;f>e;e++)if(this.items[e]===c){d=e;break}}return c&&(this.items.splice(d,1),b.silent||this.emit("item.remove",c,d),b.noSync||"function"==typeof this.sync&&this.sync("remove",a,d)),c},/**
 * Clears the whole list
 * @param  {Object} options Options object
 * {
 *     silent: true,    //Disable event emitting
 *     noSync: true     //Don't call sync method
 * }
 *
 * @fires item.clear
 * Fires an item.clear event if item was succesfully cleared. It will not fire any events on an empty list
 *
 * @returns {Number} Returns the amount of removed items
 */
List.prototype.clear=function(a){if(a=a||{},0===this.items.length)return 0;var b=this.toArray();return this.items=[],a.silent||this.emit("item.clear",b),a.noSync||"function"==typeof this.sync&&this.sync("clear",b),b.length},/**
 * Returns list items as an array
 * @method toArray
 * @return {Array} Returns an array of list items
 */
List.prototype.toArray=function(){return this.items.map(function(a){return a.properties})},/**
 * Compatibility, does the same as toArray()
 * @method toJSON   
 * @return {Array} Returns an array of list items
 */
List.prototype.toJSON=function(){return this.toArray()},/**
 * Search through list items and returns the first matching item
 *
 * @method findOne
 * @param {Object} searchfor Searching for object
 * @return {Object} Returns the first matched item or null. The returning item is a XQCore.Model object
 */
List.prototype.findOne=function(a){var b;if(b=this.items)for(var c=0;c<b.length;c++){var d,e=b[c];for(var f in a)if(a.hasOwnProperty(f)){if(e.properties[f]&&e.properties[f]===a[f]){d=!0;break}d=!1}if(d===!0)return e}return null},/**
 * Search through list items and returns all matching items
 *
 * @method find
 * @param {Object} searchfor Searching for object
 * @return {Object} Returns all matched item or an empty array.
 * The returning value is an array of XQCore.Model objects
 */
List.prototype.find=function(a){var b,c=[];if(b=this.items)for(var d=0;d<b.length;d++){var e,f=b[d];for(var g in a)if(a.hasOwnProperty(g)){if(f.properties[g]&&f.properties[g]===a[g]){e=!0;break}e=!1}e===!0&&c.push(f)}return c},/**
 * Calls a function on each item.
 * Optionally traverse the `initial` object through all methods and returns it at the end.
 *
 * @method each
 * @param  {Object}   initial Object which will be traversed and returned at the end
 * @param  {Function} fn      Funtion to be called on each item. Gets the model as first arg and the traversing object as second arg.
 * @returns {Object}          Returns a traversed object
 */
List.prototype.each=function(a,b){"function"==typeof a&&(b=a,a={});for(var c=a,d=0,e=this.items.length;e>d;d++)c=b(this.items[d],c);return c},
//--
module.exports=List;var XQCore=require("./xqcore-core"),SyncList=function(a,b){/**
     * @property {Boolean} noAutoRegister Disables auto registration. SyncList.register() must be called manually to register the list at the socket server.
     */
this.noAutoRegister=!1,
//Call XQCore.List constructor
XQCore.List.call(this,a,b),this.server=this.server||location.protocol+"//"+location.hostname,this.port=this.port||XQCore.socketPort,this.path=this.path||"xqsocket",this.channel=this.channel||this.name.toLowerCase(),this.syncEnabled=!1,this.connectToSocket(),this.noAutoRegister||this.register()};SyncList.prototype=Object.create(XQCore.List.prototype),SyncList.prototype.constructor=SyncList,/**
 * Inherits a sync model prototype
 * @method inherit
 * @param  {String} name    model name
 * @param  {Object} options SyncList properties
 * @return {Object}         Returns a XQCore.SyncList prototype
 */
SyncList.inherit=function(a,b){"object"==typeof a&&(b=a,a=void 0);var c=function(){XQCore.SyncList.call(this,a,b)};return c.prototype=Object.create(XQCore.SyncList.prototype),c.prototype.constructor=c,c},/**
 * Connect to a socket server
 *
 * @method connectToSocket
 */
SyncList.prototype.connectToSocket=function(){var a=this.server+":"+this.port+"/"+this.path;this.socket||(this.debug("Connect to socket:",a),this.socket=new XQCore.Socket(a,this.channel))},/**
 * Register a sync list at the socket server. This action is called automatically except the noAutoRegister option is set.
 * @param  {Boolean} enableSync Enables/Disables the initial sync. Defaults to false
 */
SyncList.prototype.register=function(a){var b=this;"boolean"==typeof a&&(this.syncEnabled=a),b.debug("Register synclist at server:",b.name);var c={noSync:!0};b.socket.on("synclist.push",function(a){b.push(a,c)}),b.socket.on("synclist.unshift",function(a){b.push(a,c)}),b.socket.on("synclist.pop",function(){b.push(c)}),b.socket.on("synclist.shift",function(){b.push(c)}),b.socket.on("synclist.update",function(a,d){b.update(a,d,c)}),b.socket.on("synclist.clear",function(){b.clear(c)}),b.socket.on("synclist.init",function(a){console.log("Got initial data request:",a),b.push(a,c)}),b.socket.send("synclist.register",{name:b.name})},SyncList.prototype.unregister=function(){this.debug("Unregister synclist at server:",this.name),this.socket.send("synclist.unregister",{name:this.name}),this.socket.off("synclist.push"),this.socket.off("synclist.unshift"),this.socket.off("synclist.pop"),this.socket.off("synclist.shift"),this.socket.off("synclist.update"),this.socket.off("synclist.clear"),this.socket.off("synclist.init")},/**
 * Send a socket message to the server
 * @param  {String} eventName Event name
 * @param  {Object} data      Data object
 */
SyncList.prototype.emitRemote=function(a,b){this.socket.send(a,b)},SyncList.prototype.sync=function(a){if(this.syncEnabled){var b=Array.prototype.slice.call(arguments,1);b.unshift("syncmodel."+a),this.emitRemote.apply(this,b)}},SyncList.prototype.fetchList=function(){this.emitRemote("synclist.fetch")},
//--
module.exports=SyncList;var XQCore=require("./xqcore-core"),Service=function(a,b){if(
//Call Event constructor
XQCore.Event.call(this),"object"==typeof arguments[0]&&(b=a,a=b.name),/**
     * Enable debug mode
     * @public
     * @type {Boolean}
     */
this.logLevel=XQCore.logLevel,void 0===b&&(b={}),"function"==typeof b?b.call(this,this):XQCore.extend(this,b),this.conf=b,this.name=(a?a.replace(/Service$/,""):"Nameless")+"Service",!this.model&&!this.list)throw new Error("Service is not connected to any model or list!");if(this.model&&this.list)throw new Error("Service is connected to a model and a list. This is not allowed!");if(this.isListService=!1,this.model)this.schema=this.schema||this.model.schema||null;else{if(this.schema=this.schema||null,!this.schema&&"function"==typeof this.list.model){var c=new this.list.model;this.schema=c.schema}this.isListService=!0}this.__state="ready"};
//Extend with ready state
XQCore.extend(Service.prototype,XQCore.ReadyState.prototype),XQCore.extend(Service.prototype,XQCore.Event.prototype),XQCore.extend(Service.prototype,new XQCore.Logger),
// XQCore.extend(Service.prototype, XQCore.Sync.prototype);
/**
 * Inherits a model prototype
 * @method inherit
 * @param  {String} name    model name
 * @param  {Object} options Service properties
 * @return {Object}         Returns a XQCore.Service prototype
 */
Service.inherit=function(a,b){"object"==typeof a&&(b=a,a=void 0);var c=function(c,d){
//TODO call this later, ready state will be set before _options had been run
XQCore.Service.call(this,a,b),c&&("string"==typeof c?a=c:d=c,"function"==typeof d?d.call(this,this):"object"==typeof d&&XQCore.extend(this,d))};return c.prototype=Object.create(XQCore.Service.prototype),c.prototype.constructor=c,c},/**
 * Change the model state
 *
 * @method state
 * @param {String} state New state
 */
Service.prototype.state=function(a){this.__state=a,this.emit("state."+a),this.emit("state.change",a)},/**
 * Get the current model state
 *
 * @method getState
 */
Service.prototype.getState=function(){return this.__state},
// Service.prototype.toJSON = function() {
//     return {};
// };
//--
module.exports=Service;