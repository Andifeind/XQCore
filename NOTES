* Model state
model.state(<String state>)
Setzt einen model state. Gekoppelte views können den State verarbeiten.
Jedes model.state feuert ein state.mystate event

States:
 - starting		Default state
 - ready		State after init was done
 - syncing		On sending a request
 - progress		On doing a long job
 - success		On server result or long job was success
 - invalid		On validation failed
 - failed		On request to server or long job failed


Gekoppelt:
presenter lauscht auf state.mystate und ruft dann in der view onStateChange auf



* Leite events an die view
Gekoppelt:
in der view wird auf ein event gelauscht.
events: {
	'submit #myform': 'createItem'
}

sofern createItem im presenter nicht existiert leite an model weiter und rufe dort createItem als funktion auf. Übergeben wird nur data.

model.createItem = function(data) {
	
}


* Events

Model func                       Event                 View func        -------------------------------------------------------------------------------
 set(data)					             data.change           render
 set(key, data)			 	          *item.change          *update
~append(path, data)			        *subset.append        *append
~prepend(path, data)			      *subset.prepend       *prepend
~remove(path, index)			      *subset.remove        *remove
*insert(path, index, data)	    *subset.insert        *insert
